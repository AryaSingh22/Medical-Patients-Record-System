"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/actor";
exports.ids = ["vendor-chunks/actor"];
exports.modules = {

/***/ "(ssr)/./node_modules/actor/src/lib.js":
/*!***************************************!*\
  !*** ./node_modules/actor/src/lib.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abort: () => (/* binding */ abort),\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   effect: () => (/* binding */ effect),\n/* harmony export */   effects: () => (/* binding */ effects),\n/* harmony export */   exit: () => (/* binding */ exit),\n/* harmony export */   fork: () => (/* binding */ fork),\n/* harmony export */   group: () => (/* binding */ group),\n/* harmony export */   isInstruction: () => (/* binding */ isInstruction),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   join: () => (/* binding */ join),\n/* harmony export */   listen: () => (/* binding */ listen),\n/* harmony export */   loop: () => (/* binding */ loop),\n/* harmony export */   main: () => (/* binding */ main),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   resume: () => (/* binding */ resume),\n/* harmony export */   send: () => (/* binding */ send),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   spawn: () => (/* binding */ spawn),\n/* harmony export */   suspend: () => (/* binding */ suspend),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   then: () => (/* binding */ then),\n/* harmony export */   wait: () => (/* binding */ wait)\n/* harmony export */ });\n/* harmony import */ var _task_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./task.js */ \"(ssr)/./node_modules/actor/src/task.js\");\n\n\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nconst effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nfunction* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nconst suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nfunction* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nconst wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nconst send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nconst listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nconst effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nfunction* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nconst tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nconst none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nconst all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nfunction* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nconst isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nconst isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nconst main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // ⚠️ Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nfunction* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nconst fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nconst exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nconst terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nconst abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nfunction* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nfunction* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nconst loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsZUFBZTs7QUFFZjs7QUFFQSxXQUFXLG9CQUFvQjtBQUMvQixpQ0FBaUM7O0FBRWpDLFdBQVcsMEJBQTBCO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvYWN0b3Ivc3JjL2xpYi5qcz81YjlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRhc2sgZnJvbSBcIi4vdGFzay5qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi90YXNrLmpzXCJcblxuLyoqXG4gKiBUdXJucyBhIHRhc2sgKHRoYXQgbmV2ZXIgZmFpbHMgb3Igc2VuZHMgbWVzc2FnZXMpIGludG8gYW4gZWZmZWN0IG9mIGl0J3NcbiAqIHJlc3VsdC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUYXNrLlRhc2s8VCwgbmV2ZXI+fSB0YXNrXG4gKiBAcmV0dXJucyB7VGFzay5FZmZlY3Q8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBlZmZlY3QgPSBmdW5jdGlvbiogKHRhc2spIHtcbiAgY29uc3QgbWVzc2FnZSA9IHlpZWxkKiB0YXNrXG4gIHlpZWxkKiBzZW5kKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogR2V0cyBhIGhhbmRsZSB0byB0aGUgdGFzayB0aGF0IGludm9rZWQgaXQuIFVzZWZ1bCB3aGVuIHRhc2sgbmVlZHMgdG9cbiAqIHN1c3BlbmQgZXhlY3V0aW9uIHVudGlsIHNvbWUgb3V0c2lkZSBldmVudCBvY2N1cnMsIGluIHdoaWNoIGNhc2UgaGFuZGxlXG4gKiBjYW4gYmUgdXNlZCByZXN1bWUgZXhlY3V0aW9uIChzZWUgYHN1c3BlbmRgIGNvZGUgZXhhbXBsZSBmb3IgbW9yZSBkZXRhaWxzKVxuICpcbiAqIEB0ZW1wbGF0ZSBULCBNLCBYXG4gKiBAcmV0dXJucyB7VGFzay5UYXNrPFRhc2suQ29udHJvbGxlcjxULCBYLCBNPiwgbmV2ZXI+fVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGN1cnJlbnQoKSB7XG4gIHJldHVybiAvKiogQHR5cGUge1Rhc2suQ29udHJvbGxlcjxULCBYLCBNPn0gKi8gKHlpZWxkIENVUlJFTlQpXG59XG5cbi8qKlxuICogU3VzcGVuZHMgdGhlIGN1cnJlbnQgdGFzayAodGFzayB0aGF0IGludm9rZXMgaXQpLCAgd2hpY2ggY2FuIHRoZW4gYmVcbiAqIHJlc3VtZWQgZnJvbSBhbm90aGVyIHRhc2sgb3IgYW4gb3V0c2lkZSBldmVudCAoZS5nLiBgc2V0VGltZW91dGAgY2FsbGJhY2spXG4gKiBieSBjYWxsaW5nIHRoZSBgcmVzdW1lYCB3aXRoIGFuIHRhc2sncyBoYW5kbGUuXG4gKlxuICogQ2FsbGluZyB0aGlzIGluIGFsbW9zdCBhbGwgY2FzZXMgaXMgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYGN1cnJlbnQoKWAgaW5cbiAqIG9yZGVyIHRvIG9idGFpbiBhIGBoYW5kbGVgIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8gYHJlc3VtZWAgZnVuY3Rpb25cbiAqIHRvIHJlc3VtZSB0aGUgZXhlY3V0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgdGFzayBuZXZlciBmYWlscywgYWx0aG91Z2ggaXQgbWF5IG5ldmVyIHJlc3VtZSBlaXRoZXIuIEhvd2V2ZXJcbiAqIHlvdSBjYW4gdXRpbGl6ZSBgZmluYWxseWAgYmxvY2sgdG8gZG8gYSBuZWNlc3NhcnkgY2xlYW51cCBpbiBjYXNlIGV4ZWN1dGlvblxuICogaXMgYWJvcnRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IGN1cnJlbnQsIHN1c3BlbmQsIHJlc3VtZSB9IGZyb20gXCJhY3RvclwiXG4gKiBmdW5jdGlvbiAqIHNsZWVwKGR1cmF0aW9uKSB7XG4gKiAgICAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdGhpcyB0YXNrIHNvIHdlIGNhbiByZXN1bWUgaXQuXG4gKiAgICBjb25zdCBzZWxmID0geWllbGQgKiBjdXJyZW50KClcbiAqICAgIC8vIHJlc3VtZSB0aGlzIHRhc2sgd2hlbiB0aW1lb3V0IGZpcmVzXG4gKiAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzdW1lKHNlbGYpLCBkdXJhdGlvbilcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIHN1c3BlbmQgdGhpcyB0YXNrIG5vdGhpbmcgYmVsb3cgdGhpcyBsaW5lIHdpbGwgcnVuIHVudGlsIHRhc2sgaXNcbiAqICAgICAgLy8gcmVzdW1lZC5cbiAqICAgICAgeWllbGQgKiBzdXNwZW5kKClcbiAqICAgIH0gZmluYWxseSB7XG4gKiAgICAgIC8vIGlmIHRhc2sgaXMgYWJvcnRlZCBmaW5hbGx5IGJsb2NrIHdpbGwgc3RpbGwgcnVuIHdoaWNoIGdpdmVuIHlvdVxuICogICAgICAvLyBjaGFuY2UgdG8gY2xlYW51cC5cbiAqICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICogICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMge1Rhc2suVGFzazx2b2lkLCBuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBzdXNwZW5kID0gZnVuY3Rpb24qICgpIHtcbiAgeWllbGQgU1VTUEVORFxufVxuXG4vKipcbiAqIFN1c3BlbmRzIGV4ZWN1dGlvbiBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcywgYWZ0ZXIgd2hpY2hcbiAqIGV4ZWN1dGlvbiBpcyByZXN1bWVkICh1bmxlc3MgaXQgd2FzIGFib3J0ZWQgaW4gdGhlIG1lYW50aW1lKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGZ1bmN0aW9uICogZGVtbygpIHtcbiAqICAgIGNvbnNvbGUubG9nKFwiSSdtIGdvaW5nIHRvIHRha2Ugc21hbGwgbmFwXCIpXG4gKiAgICB5aWVsZCAqIHNsZWVwKDIwMClcbiAqICAgIGNvbnNvbGUubG9nKFwiSSBhbSBiYWNrIHRvIHdvcmtcIilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dXG4gKiBAcmV0dXJucyB7VGFzay5UYXNrPHZvaWQsIG5ldmVyPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBzbGVlcChkdXJhdGlvbiA9IDApIHtcbiAgY29uc3QgdGFzayA9IHlpZWxkKiBjdXJyZW50KClcbiAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KGVucXVldWUsIGR1cmF0aW9uLCB0YXNrKVxuXG4gIHRyeSB7XG4gICAgeWllbGQqIHN1c3BlbmQoKVxuICB9IGZpbmFsbHkge1xuICAgIGNsZWFyVGltZW91dChpZClcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVzIGVxdWl2YWxlbnQgb2YgYGF3YWl0YCBpbiBhc3luYyBmdW5jdGlvbnMuIFNwZWNpZmljYWxseSBpdCB0YWtlc1xuICogYSB2YWx1ZSB0aGF0IHlvdSBjYW4gYGF3YWl0YCBvbiAodGhhdCBpcyBgUHJvbWlzZTxUPnxUYCkgYW5kIHN1c3BlbmRzXG4gKiBleGVjdXRpb24gdW50aWwgcHJvbWlzZSBpcyBzZXR0bGVkLiBJZiBwcm9taXNlIHN1Y2NlZWRzIGV4ZWN1dGlvbiBpcyByZXN1bWVkXG4gKiB3aXRoIGBUYCBvdGhlcndpc2UgYW4gZXJyb3Igb2YgdHlwZSBgWGAgaXMgdGhyb3duICh3aGljaCBpcyBieSBkZWZhdWx0XG4gKiBgdW5rbm93bmAgc2luY2UgcHJvbWlzZXMgZG8gbm90IGVuY29kZSBlcnJvciB0eXBlKS5cbiAqXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBkZWFsIHdpdGggcG90ZW50aWFsbHkgYXN5bmMgc2V0IG9mIG9wZXJhdGlvbnNcbiAqIHdpdGhvdXQgaGF2aW5nIHRvIGNoZWNrIGlmIHRoaW5nIGlzIGEgcHJvbWlzZSBhdCBldmVyeSBzdGVwLlxuICpcbiAqIFBsZWFzZSBub3RlOiBUaGlzIHRoYXQgZXhlY3V0aW9uIGlzIHN1c3BlbmRlZCBldmVuIGlmIGdpdmVuIHZhbHVlIGlzIG5vdCBhXG4gKiBwcm9taXNlLCBob3dldmVyIHNjaGVkdWxlciB3aWxsIHN0aWxsIHJlc3VtZSBpdCBpbiB0aGUgc2FtZSB0aWNrIG9mIHRoZSBldmVudFxuICogbG9vcCBhZnRlciwganVzdCBwcm9jZXNzaW5nIG90aGVyIHNjaGVkdWxlZCB0YXNrcy4gVGhpcyBhdm9pZHMgcHJvYmxlbWF0aWNcbiAqIHJhY2UgY29uZGl0aXRpb25zIHRoYXQgY2FuIG90aGVyd2lzZSBvY2N1ciB3aGVuIHZhbHVlcyBhcmUgc29tZXRpbWVzIHByb21pc2VzXG4gKiBhbmQgb3RoZXIgdGltZXMgYXJlIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGZ1bmN0aW9uICogZmV0Y2hKU09OICh1cmwsIG9wdGlvbnMpIHtcbiAqICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgKiB3YWl0KGZldGNoKHVybCwgb3B0aW9ucykpXG4gKiAgICBjb25zdCBqc29uID0geWllbGQgKiB3YWl0KHJlc3BvbnNlLmpzb24oKSlcbiAqICAgIHJldHVybiBqc29uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUgVCwgW1g9dW5rbm93bl1cbiAqIEBwYXJhbSB7VGFzay5Bd2FpdDxUPn0gaW5wdXRcbiAqIEByZXR1cm5zIHtUYXNrLlRhc2s8VCwgRXJyb3I+fVxuICovXG5leHBvcnQgY29uc3Qgd2FpdCA9IGZ1bmN0aW9uKiAoaW5wdXQpIHtcbiAgY29uc3QgdGFzayA9IHlpZWxkKiBjdXJyZW50KClcbiAgaWYgKGlzQXN5bmMoaW5wdXQpKSB7XG4gICAgbGV0IGZhaWxlZCA9IGZhbHNlXG4gICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgIGxldCBvdXRwdXQgPSB1bmRlZmluZWRcbiAgICBpbnB1dC50aGVuKFxuICAgICAgdmFsdWUgPT4ge1xuICAgICAgICBmYWlsZWQgPSBmYWxzZVxuICAgICAgICBvdXRwdXQgPSB2YWx1ZVxuICAgICAgICBlbnF1ZXVlKHRhc2spXG4gICAgICB9LFxuICAgICAgZXJyb3IgPT4ge1xuICAgICAgICBmYWlsZWQgPSB0cnVlXG4gICAgICAgIG91dHB1dCA9IGVycm9yXG4gICAgICAgIGVucXVldWUodGFzaylcbiAgICAgIH1cbiAgICApXG5cbiAgICB5aWVsZCogc3VzcGVuZCgpXG4gICAgaWYgKGZhaWxlZCkge1xuICAgICAgdGhyb3cgb3V0cHV0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovIChvdXRwdXQpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbWF5IHNlZW0gcmVkdW5kdW50IGJ1dCBpdCBpcyBub3QsIGJ5IGVucXVldWluZyB0aGlzIHRhc2sgd2UgYWxsb3dcbiAgICAvLyBzY2hlZHVsZXIgdG8gcGVyZm9ybSBvdGhlciBxdWV1ZWQgdGFza3MgZmlyc3QuIFRoaXMgd2F5IG1hbnkgcmFjZVxuICAgIC8vIGNvbmRpdGlvbnMgY2FuIGJlIGF2b2lkZWQgd2hlbiB2YWx1ZXMgYXJlIHNvbWV0aW1lcyBwcm9taXNlcyBhbmQgb3RoZXJcbiAgICAvLyB0aW1lcyBhcmVuJ3QuXG4gICAgLy8gVW5saWtlIGBhd2FpdGAgaG93ZXZlciB0aGlzIHdpbGwgcmVzdW1lIGluIHRoZSBzYW1lIHRpY2suXG4gICAgbWFpbih3YWtlKHRhc2spKVxuICAgIHlpZWxkKiBzdXNwZW5kKClcbiAgICByZXR1cm4gaW5wdXRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULCBYLCBNXG4gKiBAcGFyYW0ge1Rhc2suQ29udHJvbGxlcjxULCBYLCBNPn0gdGFza1xuICogQHJldHVybnMge1Rhc2suVGFzazx2b2lkLCBuZXZlciwgbmV2ZXI+fVxuICovXG5mdW5jdGlvbiogd2FrZSh0YXNrKSB7XG4gIGVucXVldWUodGFzaylcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdmFsdWUgdmFsdWUgaXMgYSBwcm9taXNlIChvciBpdCdzIGxvb2thbGlrZSkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBub2RlXG4gKiBAcmV0dXJucyB7bm9kZSBpcyBQcm9taXNlTGlrZTxUPn1cbiAqL1xuXG5jb25zdCBpc0FzeW5jID0gbm9kZSA9PlxuICBub2RlICE9IG51bGwgJiZcbiAgdHlwZW9mICgvKiogQHR5cGUge3t0aGVuPzp1bmtub3dufX0gKi8gKG5vZGUpLnRoZW4pID09PSBcImZ1bmN0aW9uXCJcblxuLyoqXG4gKiBUYXNrIHRoYXQgc2VuZHMgZ2l2ZW4gbWVzc2FnZSAob3IgcmF0aGVyIGFuIGVmZmVjdCBwcm9kdWNpbmcgdGhpcyBtZXNzYWdlKS5cbiAqIFBsZWFzZSBub3RlLCB0aGF0IHdoaWxlIHlvdSBjb3VsZCB1c2UgYHlpZWxkIG1lc3NhZ2VgIGluc3RlYWQsIGJ1dCB5b3UnZCByaXNrXG4gKiBoYXZpbmcgdG8gZGVhbCB3aXRoIHBvdGVudGlhbCBicmVha2luZyBjaGFuZ2VzIGlmIGxpYnJhcnkgaW50ZXJuYWxzIGNoYW5nZVxuICogaW4gdGhlIGZ1dHVyZSwgd2hpY2ggaW4gZmFjdCBtYXkgaGFwcGVuIGFzIGFudGljaXBhdGVkIGltcHJvdmVtZW50cyBpblxuICogVFMgZ2VuZXJhdG9yIGluZmVyZW5jZSBjb3VsZCBlbmFibGUgcmVwbGFjZSBuZWVkIGZvciBgeWllbGQgKmAuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQzNjMyXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gbWVzc2FnZVxuICogQHJldHVybnMge1Rhc2suRWZmZWN0PFQ+fVxuICovXG5leHBvcnQgY29uc3Qgc2VuZCA9IGZ1bmN0aW9uKiAobWVzc2FnZSkge1xuICB5aWVsZCAvKiogQHR5cGUge1Rhc2suTWVzc2FnZTxUPn0gKi8gKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogVGFrZXMgc2V2ZXJhbCBlZmZlY3RzIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGVmZmVjdCBvZiB0YWdnZWRcbiAqIHZhcmlhbnRzIHNvIHRoYXQgdGhlaXIgc291cmNlIGNvdWxkIGJlIGlkZW50aWZpZWQgdmlhIGB0eXBlYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGxpc3Rlbih7XG4gKiAgICByZWFkOiBUYXNrLmVmZmVjdChkYlJlYWQpLFxuICogICAgd3JpdGU6IFRhc2suZWZmZWN0KGRiV3JpdGUpXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRhZ1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7eyBbSyBpbiBUYWddOiBUYXNrLkVmZmVjdDxUPiB9fSBzb3VyY2VcbiAqIEByZXR1cm5zIHtUYXNrLkVmZmVjdDxUYWdnZWQ8VGFnLCBUPj59XG4gKi9cbmV4cG9ydCBjb25zdCBsaXN0ZW4gPSBmdW5jdGlvbiogKHNvdXJjZSkge1xuICAvKiogQHR5cGUge1Rhc2suRm9yazx2b2lkLCBuZXZlciwgVGFnZ2VkPFRhZywgVD4+W119ICovXG4gIGNvbnN0IGZvcmtzID0gW11cbiAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgY29uc3QgW25hbWUsIGVmZmVjdF0gPSAvKiogQHR5cGUge1tUYWcsIFRhc2suRWZmZWN0PFQ+XX0gKi8gKGVudHJ5KVxuICAgIGlmIChlZmZlY3QgIT09IE5PTkUpIHtcbiAgICAgIGZvcmtzLnB1c2goeWllbGQqIGZvcmsodGFnKGVmZmVjdCwgbmFtZSkpKVxuICAgIH1cbiAgfVxuXG4gIHlpZWxkKiBncm91cChmb3Jrcylcbn1cblxuLyoqXG4gKiBUYWtlcyBzZXZlcmFsIHRhc2tzIGFuZCBjcmVhdGVzIGFuIGVmZmVjdCBvZiB0aGVtIGFsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIFRhc2suZWZmZWN0cyhbXG4gKiAgICBkYlJlYWQsXG4gKiAgICBkYldyaXRlXG4gKiBdKVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRhZ1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VGFzay5UYXNrPFQsIG5ldmVyPltdfSB0YXNrc1xuICogQHJldHVybnMge1Rhc2suRWZmZWN0PFQ+fVxuICovXG5cbmV4cG9ydCBjb25zdCBlZmZlY3RzID0gdGFza3MgPT5cbiAgdGFza3MubGVuZ3RoID4gMCA/IGJhdGNoKHRhc2tzLm1hcChlZmZlY3QpKSA6IE5PTkVcblxuLyoqXG4gKiBUYWtlcyBzZXZlcmFsIGVmZmVjdHMgYW5kIGNvbWJpbmVzIHRoZW0gaW50byBhIG9uZS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUYXNrLkVmZmVjdDxUPltdfSBlZmZlY3RzXG4gKiBAcmV0dXJucyB7VGFzay5FZmZlY3Q8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogYmF0Y2goZWZmZWN0cykge1xuICBjb25zdCBmb3JrcyA9IFtdXG4gIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICBmb3Jrcy5wdXNoKHlpZWxkKiBmb3JrKGVmZmVjdCkpXG4gIH1cblxuICB5aWVsZCogZ3JvdXAoZm9ya3MpXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRhZ1xuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7dHlwZTogVGFnfSAmIHtbSyBpbiBUYWddOiBUfX0gVGFnZ2VkXG4gKi9cbi8qKlxuICogVGFncyBhbiBlZmZlY3QgYnkgYm94aW5nIGVhY2ggZXZlbnQgd2l0aCBhbiBvYmplY3QgdGhhdCBoYXMgYHR5cGVgIGZpZWxkXG4gKiBjb3JyZXNwb25kaW5nIHRvIGdpdmVuIHRhZyBhbmQgc2FtZSBuYW1lZCBmaWVsZCBob2xkaW5nIG9yaWdpbmFsIG1lc3NhZ2VcbiAqIGUuZy4gZ2l2ZW4gYG51bXNgIGVmZmVjdCB0aGF0IHByb2R1Y2VzIG51bWJlcnMsIGB0YWcobnVtcywgXCJpbmNcIilgIHdvdWxkXG4gKiBjcmVhdGUgYW4gZWZmZWN0IHRoYXQgcHJvZHVjZXMgZXZlbnRzIGxpa2UgYHt0eXBlOidpbmMnLCBpbmM6MX1gLlxuICpcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBUYWdcbiAqIEB0ZW1wbGF0ZSBULCBNLCBYXG4gKiBAcGFyYW0ge1Rhc2suVGFzazxULCBYLCBNPn0gZWZmZWN0XG4gKiBAcGFyYW0ge1RhZ30gdGFnXG4gKiBAcmV0dXJucyB7VGFzay5UYXNrPFQsIFgsIFRhZ2dlZDxUYWcsIE0+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRhZyA9IChlZmZlY3QsIHRhZykgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICBlZmZlY3QgPT09IE5PTkVcbiAgICA/IE5PTkVcbiAgICA6IGVmZmVjdCBpbnN0YW5jZW9mIFRhZ2dlclxuICAgID8gbmV3IFRhZ2dlcihbLi4uZWZmZWN0LnRhZ3MsIHRhZ10sIGVmZmVjdC5zb3VyY2UpXG4gICAgOiBuZXcgVGFnZ2VyKFt0YWddLCBlZmZlY3QpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRhZ1xuICogQHRlbXBsYXRlIFN1Y2Nlc3MsIEZhaWx1cmUsIE1lc3NhZ2VcbiAqXG4gKiBAaW1wbGVtZW50cyB7VGFzay5UYXNrPFN1Y2Nlc3MsIEZhaWx1cmUsIFRhZ2dlZDxUYWcsIE1lc3NhZ2U+Pn1cbiAqIEBpbXBsZW1lbnRzIHtUYXNrLkNvbnRyb2xsZXI8U3VjY2VzcywgRmFpbHVyZSwgVGFnZ2VkPFRhZywgTWVzc2FnZT4+fVxuICovXG5jbGFzcyBUYWdnZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtUYXNrLlRhc2s8U3VjY2VzcywgRmFpbHVyZSwgTWVzc2FnZT59IHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YWdzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWdzLCBzb3VyY2UpIHtcbiAgICB0aGlzLnRhZ3MgPSB0YWdzXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VcbiAgICAvKiogQHR5cGUge1Rhc2suQ29udHJvbGxlcjxTdWNjZXNzLCBGYWlsdXJlLCBNZXNzYWdlPn0gKi9cbiAgICB0aGlzLmNvbnRyb2xsZXJcbiAgfVxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSB0aGlzLnNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUYXNrLlRhc2tTdGF0ZTxTdWNjZXNzLCBNZXNzYWdlPn0gc3RhdGVcbiAgICogQHJldHVybnMge1Rhc2suVGFza1N0YXRlPFN1Y2Nlc3MsIFRhZ2dlZDxUYWcsIE1lc3NhZ2U+Pn1cbiAgICovXG4gIGJveChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5kb25lKSB7XG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChzdGF0ZS52YWx1ZSkge1xuICAgICAgICBjYXNlIFNVU1BFTkQ6XG4gICAgICAgIGNhc2UgQ1VSUkVOVDpcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtUYXNrLlRhc2tTdGF0ZTxTdWNjZXNzLCBUYWdnZWQ8VGFnLCBNZXNzYWdlPj59ICovIChcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgLy8gSW5zdGVhZCBvZiBib3hpbmcgcmVzdWx0IGF0IGVhY2ggdHJhbnNmb3JtIHN0ZXAgd2UgcGVyZm9ybSBpbi1wbGFjZVxuICAgICAgICAgIC8vIG11dGF0aW9uIGFzIHdlIGtub3cgbm90aGluZyBlbHNlIGlzIGFjY2Vzc2luZyB0aGlzIHZhbHVlLlxuICAgICAgICAgIGNvbnN0IHRhZ2dlZCA9IC8qKiBAdHlwZSB7eyBkb25lOiBmYWxzZSwgdmFsdWU6IGFueSB9fSAqLyAoc3RhdGUpXG4gICAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRhZ2dlZFxuICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgICAgICAgdmFsdWUgPSB3aXRoVGFnKHRhZywgdmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZ2dlZC52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgcmV0dXJuIHRhZ2dlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1Rhc2suSW5zdHJ1Y3Rpb248TWVzc2FnZT59IGluc3RydWN0aW9uXG4gICAqL1xuICBuZXh0KGluc3RydWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94KHRoaXMuY29udHJvbGxlci5uZXh0KGluc3RydWN0aW9uKSlcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtGYWlsdXJlfSBlcnJvclxuICAgKi9cbiAgdGhyb3coZXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5ib3godGhpcy5jb250cm9sbGVyLnRocm93KGVycm9yKSlcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtTdWNjZXNzfSB2YWx1ZVxuICAgKi9cbiAgcmV0dXJuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94KHRoaXMuY29udHJvbGxlci5yZXR1cm4odmFsdWUpKVxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlRhZ2dlZEVmZmVjdFwiXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGVtcHR5IGBFZmZlY3RgLCB0aGF0IGlzIHByb2R1Y2VzIG5vIG1lc3NhZ2VzLiBLaW5kIG9mIGxpa2UgYFtdYCBvclxuICogYFwiXCJgIGJ1dCBmb3IgZWZmZWN0cy5cbiAqXG4gKiBAdHlwZSB7KCkgPT4gVGFzay5FZmZlY3Q8bmV2ZXI+fVxuICovXG5leHBvcnQgY29uc3Qgbm9uZSA9ICgpID0+IE5PTkVcblxuLyoqXG4gKiBUYWtlcyBpdGVyYWJsZSBvZiB0YXNrcyBhbmQgcnVucyB0aGVtIGNvbmN1cnJlbnRseSwgcmV0dXJuaW5nIGFycmF5IG9mXG4gKiByZXN1bHRzIGluIGFuIG9yZGVyIG9mIHRhc2tzIChub3QgdGhlIG9yZGVyIG9mIGNvbXBsZXRpb24pLiBJZiBhbnkgb2YgdGhlXG4gKiB0YXNrcyBmYWlsIGFsbCB0aGUgcmVzdCBhcmUgYWJvcnRlZCBhbmQgZXJyb3IgaXMgdGhyb3cgaW50byBjYWxsaW5nIHRhc2suXG4gKlxuICogPiBUaGlzIGlzIGJhc2ljYWxseSBlcXVpdmFsZW50IG9mIGBQcm9taXNlLmFsbGAgZXhjZXB0IGNhbmNlbGF0aW9uIGxvZ2ljXG4gKiBiZWNhdXNlIHRhc2tzIHVubGlrZSBwcm9taXNlcyBjYW4gYmUgY2FuY2VsbGVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBYXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFRhc2suVGFzazxULCBYPj59IHRhc2tzXG4gKiBAcmV0dXJucyB7VGFzay5UYXNrPFRbXSwgWD59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSBmdW5jdGlvbiogKHRhc2tzKSB7XG4gIGNvbnN0IHNlbGYgPSB5aWVsZCogY3VycmVudCgpXG5cbiAgLyoqIEB0eXBlIHsoaWQ6bnVtYmVyKSA9PiAodmFsdWU6VCkgPT4gdm9pZH0gKi9cbiAgY29uc3Qgc3VjY2VlZCA9IGlkID0+IHZhbHVlID0+IHtcbiAgICBkZWxldGUgZm9ya3NbaWRdXG4gICAgcmVzdWx0c1tpZF0gPSB2YWx1ZVxuICAgIGNvdW50IC09IDFcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIGVucXVldWUoc2VsZilcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUgeyhlcnJvcjpYKSA9PiB2b2lkfSAqL1xuICBjb25zdCBmYWlsID0gZXJyb3IgPT4ge1xuICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGZvcmtzKSB7XG4gICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgIGVucXVldWUoYWJvcnQoaGFuZGxlLCBlcnJvcikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5xdWV1ZShhYm9ydChzZWxmLCBlcnJvcikpXG4gIH1cblxuICAvKiogQHR5cGUge1Rhc2suRm9yazx2b2lkLCBuZXZlcj5bXX0gKi9cbiAgbGV0IGZvcmtzID0gW11cbiAgbGV0IGNvdW50ID0gMFxuICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICBmb3Jrcy5wdXNoKHlpZWxkKiBmb3JrKHRoZW4odGFzaywgc3VjY2VlZChjb3VudCsrKSwgZmFpbCkpKVxuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoY291bnQpXG5cbiAgaWYgKGNvdW50ID4gMCkge1xuICAgIHlpZWxkKiBzdXNwZW5kKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRhZ1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VGFnfSB0YWdcbiAqIEBwYXJhbSB7VGFzay5NZXNzYWdlPFQ+fSB2YWx1ZVxuICovXG5jb25zdCB3aXRoVGFnID0gKHRhZywgdmFsdWUpID0+XG4gIC8qKiBAdHlwZSB7VGFnZ2VkPFRhZywgVD59ICovXG4gICh7IHR5cGU6IHRhZywgW3RhZ106IHZhbHVlIH0pXG5cbi8qKlxuICogS2luZCBvZiBsaWtlIHByb21pc2UudGhlbiB3aGljaCBpcyBoYW5keSB3aGVuIHlvdSB3YW50IHRvIGV4dHJhY3QgcmVzdWx0XG4gKiBmcm9tIHRoZSBnaXZlbiB0YXNrIGZyb20gdGhlIG91dHNpZGUuXG4gKlxuICogQHRlbXBsYXRlIFQsIFUsIFgsIE1cbiAqIEBwYXJhbSB7VGFzay5UYXNrPFQsIFgsIE0+fSB0YXNrXG4gKiBAcGFyYW0geyh2YWx1ZTpUKSA9PiBVfSByZXNvbHZlXG4gKiBAcGFyYW0geyhlcnJvcjpYKSA9PiBVfSByZWplY3RcbiAqIEByZXR1cm5zIHtUYXNrLlRhc2s8VSwgbmV2ZXIsIE0+fVxuICovXG5leHBvcnQgZnVuY3Rpb24qIHRoZW4odGFzaywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlc29sdmUoeWllbGQqIHRhc2spXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlamVjdCgvKiogQHR5cGUge1h9ICovIChlcnJvcikpXG4gIH1cbn1cblxuLy8gU3BlY2lhbCBjb250cm9sIGluc3RydWN0aW9ucyByZWNvZ25pemVkIGJ5IGEgc2NoZWR1bGVyLlxuY29uc3QgQ1VSUkVOVCA9IFN5bWJvbChcImN1cnJlbnRcIilcbmNvbnN0IFNVU1BFTkQgPSBTeW1ib2woXCJzdXNwZW5kXCIpXG4vKiogQHR5cGVkZWYge3R5cGVvZiBTVVNQRU5EfHR5cGVvZiBDVVJSRU5UfSBDb250cm9sICovXG5cbi8qKlxuICogQHRlbXBsYXRlIE1cbiAqIEBwYXJhbSB7VGFzay5JbnN0cnVjdGlvbjxNPn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBNfVxuICovXG5leHBvcnQgY29uc3QgaXNNZXNzYWdlID0gdmFsdWUgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBTVVNQRU5EOlxuICAgIGNhc2UgQ1VSUkVOVDpcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIE1cbiAqIEBwYXJhbSB7VGFzay5JbnN0cnVjdGlvbjxNPn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBDb250cm9sfVxuICovXG5leHBvcnQgY29uc3QgaXNJbnN0cnVjdGlvbiA9IHZhbHVlID0+ICFpc01lc3NhZ2UodmFsdWUpXG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFgsIE1cbiAqIEBpbXBsZW1lbnRzIHtUYXNrLlRhc2tHcm91cDxULCBYLCBNPn1cbiAqL1xuY2xhc3MgR3JvdXAge1xuICAvKipcbiAgICogQHRlbXBsYXRlIFQsIFgsIE1cbiAgICogQHBhcmFtIHtUYXNrLkNvbnRyb2xsZXI8VCwgWCwgTT58VGFzay5Gb3JrPFQsIFgsIE0+fSBtZW1iZXJcbiAgICogQHJldHVybnMge1Rhc2suR3JvdXA8VCwgWCwgTT59XG4gICAqL1xuICBzdGF0aWMgb2YobWVtYmVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7e2dyb3VwPzpUYXNrLlRhc2tHcm91cDxULCBYLCBNPn19ICovIChtZW1iZXIpLmdyb3VwIHx8IE1BSU5cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFQsIFgsIE1cbiAgICogQHBhcmFtIHsoVGFzay5Db250cm9sbGVyPFQsIFgsIE0+fFRhc2suRm9yazxULCBYLCBNPikgJiB7Z3JvdXA/OlRhc2suVGFza0dyb3VwPFQsIFgsIE0+fX0gbWVtYmVyXG4gICAqIEBwYXJhbSB7VGFzay5UYXNrR3JvdXA8VCwgWCwgTT59IGdyb3VwXG4gICAqL1xuICBzdGF0aWMgZW5xdWV1ZShtZW1iZXIsIGdyb3VwKSB7XG4gICAgbWVtYmVyLmdyb3VwID0gZ3JvdXBcbiAgICBncm91cC5zdGFjay5hY3RpdmUucHVzaChtZW1iZXIpXG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFzay5Db250cm9sbGVyPFQsIFgsIE0+fSBkcml2ZXJcbiAgICogQHBhcmFtIHtUYXNrLkNvbnRyb2xsZXI8VCwgWCwgTT5bXX0gW2FjdGl2ZV1cbiAgICogQHBhcmFtIHtTZXQ8VGFzay5Db250cm9sbGVyPFQsIFgsIE0+Pn0gW2lkbGVdXG4gICAqIEBwYXJhbSB7VGFzay5TdGFjazxULCBYLCBNPn0gW3N0YWNrXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZHJpdmVyLFxuICAgIGFjdGl2ZSA9IFtdLFxuICAgIGlkbGUgPSBuZXcgU2V0KCksXG4gICAgc3RhY2sgPSBuZXcgU3RhY2soYWN0aXZlLCBpZGxlKVxuICApIHtcbiAgICB0aGlzLmRyaXZlciA9IGRyaXZlclxuICAgIHRoaXMucGFyZW50ID0gR3JvdXAub2YoZHJpdmVyKVxuICAgIHRoaXMuc3RhY2sgPSBzdGFja1xuICAgIHRoaXMuaWQgPSArK0lEXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgWCwgTVxuICogQGltcGxlbWVudHMge1Rhc2suTWFpbjxULCBYLCBNPn1cbiAqL1xuY2xhc3MgTWFpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0gSURMRVxuICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKVxuICAgIHRoaXMuaWQgPSAvKiogQHR5cGUgezB9ICovICgwKVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFgsIE1cbiAqL1xuY2xhc3MgU3RhY2sge1xuICAvKipcbiAgICogQHBhcmFtIHtUYXNrLkNvbnRyb2xsZXI8VCwgWCwgTT5bXX0gW2FjdGl2ZV1cbiAgICogQHBhcmFtIHtTZXQ8VGFzay5Db250cm9sbGVyPFQsIFgsIE0+Pn0gW2lkbGVdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3RpdmUgPSBbXSwgaWRsZSA9IG5ldyBTZXQoKSkge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlXG4gICAgdGhpcy5pZGxlID0gaWRsZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7VGFzay5TdGFjazx1bmtub3duLCB1bmtub3duLCB1bmtub3duPn0gc3RhY2tcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBzaXplKHsgYWN0aXZlLCBpZGxlIH0pIHtcbiAgICByZXR1cm4gYWN0aXZlLmxlbmd0aCArIGlkbGUuc2l6ZVxuICB9XG59XG5cbi8qKlxuICogU3RhcnRzIGEgbWFpbiB0YXNrLlxuICpcbiAqIEBwYXJhbSB7VGFzay5UYXNrPHZvaWQsIG5ldmVyPn0gdGFza1xuICovXG5leHBvcnQgY29uc3QgbWFpbiA9IHRhc2sgPT4gZW5xdWV1ZSh0YXNrW1N5bWJvbC5pdGVyYXRvcl0oKSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgWCwgTVxuICogQHBhcmFtIHtUYXNrLkNvbnRyb2xsZXI8VCwgWCwgTT59IHRhc2tcbiAqL1xuY29uc3QgZW5xdWV1ZSA9IHRhc2sgPT4ge1xuICBsZXQgZ3JvdXAgPSBHcm91cC5vZih0YXNrKVxuICBncm91cC5zdGFjay5hY3RpdmUucHVzaCh0YXNrKVxuICBncm91cC5zdGFjay5pZGxlLmRlbGV0ZSh0YXNrKVxuXG4gIC8vIHRoZW4gd2FsayB1cCB0aGUgZ3JvdXAgY2hhaW4gYW5kIHVuYmxvY2sgdGhlaXIgZHJpdmVyIHRhc2tzLlxuICB3aGlsZSAoZ3JvdXAucGFyZW50KSB7XG4gICAgY29uc3QgeyBpZGxlLCBhY3RpdmUgfSA9IGdyb3VwLnBhcmVudC5zdGFja1xuICAgIGlmIChpZGxlLmhhcyhncm91cC5kcml2ZXIpKSB7XG4gICAgICBpZGxlLmRlbGV0ZShncm91cC5kcml2ZXIpXG4gICAgICBhY3RpdmUucHVzaChncm91cC5kcml2ZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGRyaXZlciB3YXMgbm90IGJsb2NrZWQgaXQgbXVzdCBoYXZlIGJlZW4gdW5ibG9ja2VkIGJ5XG4gICAgICAvLyBvdGhlciB0YXNrIHNvIHN0b3AgdGhlcmUuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGdyb3VwID0gZ3JvdXAucGFyZW50XG4gIH1cblxuICBpZiAoTUFJTi5zdGF0dXMgPT09IElETEUpIHtcbiAgICBNQUlOLnN0YXR1cyA9IEFDVElWRVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IF9tZXNzYWdlIG9mIHN0ZXAoTUFJTikpIHtcbiAgICAgICAgfVxuICAgICAgICBNQUlOLnN0YXR1cyA9IElETEVcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAvLyBUb3AgbGV2ZWwgdGFzayBtYXkgY3Jhc2ggYW5kIHRocm93IGFuIGVycm9yLCBidXQgZ2l2ZW4gdGhpcyBpcyBhIG1haW5cbiAgICAgICAgLy8gZ3JvdXAgd2UgZG8gbm90IHdhbnQgdG8gaW50ZXJ1cHQgb3RoZXIgdW5yZWxhdGVkIHRhc2tzLCB3aGljaCBpcyB3aHlcbiAgICAgICAgLy8gd2UgZGlzY2FyZCB0aGUgZXJyb3IgYW5kIHRoZSB0YXNrIHRoYXQgY2F1c2VkIGl0LlxuICAgICAgICBNQUlOLnN0YWNrLmFjdGl2ZS5zaGlmdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFgsIE1cbiAqIEBwYXJhbSB7VGFzay5Db250cm9sbGVyPFQsIFgsIE0+fSB0YXNrXG4gKi9cbmV4cG9ydCBjb25zdCByZXN1bWUgPSB0YXNrID0+IGVucXVldWUodGFzaylcblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgWCwgTVxuICogQHBhcmFtIHtUYXNrLkdyb3VwPFQsIFgsIE0+fSBncm91cFxuICovXG5cbmNvbnN0IHN0ZXAgPSBmdW5jdGlvbiogKGdyb3VwKSB7XG4gIGNvbnN0IHsgYWN0aXZlIH0gPSBncm91cC5zdGFja1xuICBsZXQgdGFzayA9IGFjdGl2ZVswXVxuICBncm91cC5zdGFjay5pZGxlLmRlbGV0ZSh0YXNrKVxuICB3aGlsZSAodGFzaykge1xuICAgIC8qKiBAdHlwZSB7VGFzay5UYXNrU3RhdGU8VCwgTT59ICovXG4gICAgbGV0IHN0YXRlID0gSU5JVFxuICAgIC8vIEtlZXAgcHJvY2Vzc2luZyBpbnN0dXJjdGlvbnMgdW50aWwgdGFzayBpcyBkb25lLCBpdCBzZW5kIHN1c3BlbmQgcmVxdWVzdFxuICAgIC8vIG9yIGl0J3MgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBhY3RpdmUgcXVldWUuXG4gICAgLy8g4pqg77iPIEdyb3VwIGNoYW5nZXMgcmVxdWlyZSBleHRyYSBjYXJlIHNvIHBsZWFzZSBtYWtlIHN1cmUgdG8gdW5kZXJzdGFuZFxuICAgIC8vIHRoZSBkZXRhaWwgaGVyZS4gSXQgb2NjdXJzIHdoZW4gc3Bhd25lZCB0YXNrKHMpIGFyZSBqb2luZWQgaW50byBhIGdyb3VwXG4gICAgLy8gd2hpY2ggd2lsbCBjaGFuZ2UgdGhlIHRhc2sgZHJpdmVyLCB0aGF0IGlzIHdoZW4gYHRhc2sgPT09IGFjdGl2ZVswXWAgd2lsbFxuICAgIC8vIGJlY2FtZSBmYWxzZSBhbmQgbmVlZCB0byB0byBkcm9wIHRoZSB0YXNrIGltbWVkaWF0ZWx5IG90aGVyd2lzZSByYWNlXG4gICAgLy8gY29uZGl0aW9uIHdpbGwgb2NjdXIgZHVlIHRvIHRhc2sgYmVlbiAgZHJpdmVuIGJ5IG11bHRpcGxlIGNvbmN1cnJlbnRcbiAgICAvLyBzY2hlZHVsZXJzLlxuICAgIGxvb3A6IHdoaWxlICghc3RhdGUuZG9uZSAmJiB0YXNrID09PSBhY3RpdmVbMF0pIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gc3RhdGUudmFsdWVcbiAgICAgIHN3aXRjaCAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgLy8gaWYgdGFzayBpcyBzdXNwZW5kZWQgd2UgYWRkIGl0IHRvIHRoZSBpZGxlIGxpc3QgYW5kIGJyZWFrIHRoZSBsb29wXG4gICAgICAgIC8vIHRvIG1vdmUgdG8gYSBuZXh0IHRhc2suXG4gICAgICAgIGNhc2UgU1VTUEVORDpcbiAgICAgICAgICBncm91cC5zdGFjay5pZGxlLmFkZCh0YXNrKVxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgLy8gaWYgdGFzayByZXF1ZXN0ZWQgYSBjb250ZXh0ICh3aGljaCBpcyB1c3VhbGx5IHRvIHN1c3BlbmQgaXRzZWxmKVxuICAgICAgICAvLyBwYXNzIGJhY2sgYSB0YXNrIHJlZmVyZW5jZSBhbmQgY29udGludWUuXG4gICAgICAgIGNhc2UgQ1VSUkVOVDpcbiAgICAgICAgICBzdGF0ZSA9IHRhc2submV4dCh0YXNrKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHRhc2sgc2VudCBhIG1lc3NhZ2Ugd2hpY2ggd2UgeWllbGQgdG8gdGhlIGRyaXZlciBhbmRcbiAgICAgICAgICAvLyBjb250aW51ZVxuICAgICAgICAgIHN0YXRlID0gdGFzay5uZXh0KFxuICAgICAgICAgICAgeWllbGQgLyoqIEB0eXBlIHtNICYgVGFzay5NZXNzYWdlPE0+fSovIChpbnN0cnVjdGlvbilcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0YXNrIGlzIGNvbXBsZXRlLCBvciBnb3Qgc3VzcGVuZGVkIHdlIG1vdmUgdG8gYSBuZXh0IHRhc2tcbiAgICBhY3RpdmUuc2hpZnQoKVxuICAgIHRhc2sgPSBhY3RpdmVbMF1cbiAgICBncm91cC5zdGFjay5pZGxlLmRlbGV0ZSh0YXNrKVxuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgZ2l2ZW4gdGFzayBjb25jdXJyZW50bHkgd2l0aCBhIGN1cnJlbnQgdGFzayAodGFzayB0aGF0IHNwYXduZWQgaXQpLlxuICogU3Bhd25lZCB0YXNrIGlzIGRldGFjaGVkIGZyb20gdGhlIHRhc2sgdGhhdCBzcGF3bmVkIGl0IGFuZCBpdCBjYW4gb3V0bGl2ZSBpdFxuICogYW5kIC8gb3IgZmFpbCB3aXRob3V0IGFmZmVjdGluZyBhIHRhc2sgdGhhdCBzcGF3bmVkIGl0LiBJZiB5b3UgbmVlZCB0byB3YWl0XG4gKiBvbiBjb25jdXJyZW50IHRhc2sgY29tcGxldGlvbiBjb25zaWRlciB1c2luZyBgZm9ya2AgaW5zdGVhZCB3aGljaCBjYW4gYmVcbiAqIGxhdGVyIGBqb2luZWRgLiBJZiB5b3UganVzdCB3YW50IGEgdG8gYmxvY2sgb24gdGFzayBleGVjdXRpb24geW91IGNhbiBqdXN0XG4gKiBgeWllbGQqIHdvcmsoKWAgZGlyZWN0bHkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1Rhc2suVGFzazx2b2lkLCBuZXZlciwgbmV2ZXI+fSB0YXNrXG4gKiBAcmV0dXJucyB7VGFzay5UYXNrPHZvaWQsIG5ldmVyPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBzcGF3bih0YXNrKSB7XG4gIG1haW4odGFzaylcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBnaXZlbiB0YXNrIGNvbmN1cnJlbnRseSB3aXRoIGN1cnJlbnQgdGFzayAodGhlIHRhc2sgdGhhdCBpbml0aWF0ZWRcbiAqIGZvcmspLiBGcm9rZWQgdGFzayBpcyBkZXRhY2hlZCBmcm9tIHRoZSB0YXNrIHRoYXQgY3JlYXRlZCBpdCBhbmQgaXQgY2FuXG4gKiBvdXRsaXZlIGl0IGFuZCAvIG9yIGZhaWwgd2l0aG91dCBhZmZlY3RpbmcgaXQuIFlvdSBkbyBob3dldmVyIGdldCBhIGhhbmRsZVxuICogZm9yIHRoZSBmb3JrIHdoaWNoIGNvdWxkIGJlIHVzZWQgdG8gYGpvaW5gIHRoZSB0YXNrLCBpbiB3aGljaCBjYXNlIGBqb2luaW5nYFxuICogdGFzayB3aWxsIGJsb2NrIHVudGlsIGZvcmsgZmluaXNoZXMgZXhlY3V0aW9uLlxuICpcbiAqIFRoaXMgaXMgYWxzbyBhIHByaW1hcnkgaW50ZXJmYWNlIGZvciBleGVjdXRpbmcgdGFza3MgZnJvbSB0aGUgb3V0c2lkZSBvZiB0aGVcbiAqIHRhc2sgY29udGV4dC4gRnVuY3Rpb24gcmV0dXJucyBgRm9ya2Agd2hpY2ggaW1wbGVtZW50cyBgUHJvbWlzZWAgaW50ZXJmYWNlXG4gKiBzbyBpdCBjb3VsZCBiZSBhd2FpdGVkLiBQbGVhc2Ugbm90ZSB0aGF0IGNhbGxpbmcgYGZvcmtgIGRvZXMgbm90IHJlYWxseSBkb1xuICogYW55dGhpbmcsIGl0IGxhemlseSBzdGFydHMgZXhlY3V0aW9uIHdoZW4geW91IGVpdGhlciBgYXdhaXQgZm9yayh3b3JrKCkpYFxuICogZnJvbSBhcmJpdHJheSBjb250ZXh0IG9yIGB5aWVsZCogZm9yayh3b3JrKCkpYCBpbiBhbm90aGUgdGFzayBjb250ZXh0LlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBYLCBNXG4gKiBAcGFyYW0ge1Rhc2suVGFzazxULCBYLCBNPn0gdGFza1xuICogQHBhcmFtIHtUYXNrLkZvcmtPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUYXNrLkZvcms8VCwgWCwgTT59XG4gKi9cbmV4cG9ydCBjb25zdCBmb3JrID0gKHRhc2ssIG9wdGlvbnMpID0+IG5ldyBGb3JrKHRhc2ssIG9wdGlvbnMpXG5cbi8qKlxuICogRXhpdHMgdGFzayBzdWNjZXNmdWxseSB3aXRoIGEgZ2l2ZW4gcmV0dXJuIHZhbHVlLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBNLCBYXG4gKiBAcGFyYW0gIHtUYXNrLkNvbnRyb2xsZXI8VCwgTSwgWD59IGhhbmRsZVxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHJldHVybnMge1Rhc2suVGFzazx2b2lkLCBuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBleGl0ID0gKGhhbmRsZSwgdmFsdWUpID0+IGNvbmNsdWRlKGhhbmRsZSwgeyBvazogdHJ1ZSwgdmFsdWUgfSlcblxuLyoqXG4gKiBUZXJtaW5hdGVzIHRhc2sgZXhlY3V0aW9uIGV4ZWN1dGlvbi4gT25seSB0YWtlcyB0YXNrIHRoYXQgcHJvZHVjZXMgbm9cbiAqIHJlc3VsdCwgaWYgeW91ciB0YXNrIGhhcyBub24gYHZvaWRgIHJldHVybiB0eXBlIHlvdSBzaG91bGQgdXNlIGBleGl0YCBpbnN0ZWFkLlxuICpcbiAqIEB0ZW1wbGF0ZSBNLCBYXG4gKiBAcGFyYW0ge1Rhc2suQ29udHJvbGxlcjx2b2lkLCBYLCBNPn0gaGFuZGxlXG4gKi9cbmV4cG9ydCBjb25zdCB0ZXJtaW5hdGUgPSBoYW5kbGUgPT5cbiAgY29uY2x1ZGUoaGFuZGxlLCB7IG9rOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pXG5cbi8qKlxuICogQWJvcnRzIGdpdmVuIHRhc2sgd2l0aCBhbiBlcnJvci4gVGFzayBlcnJvciB0eXBlIHNob3VsZCBtYXRjaCBwcm92aWRlZCBlcnJvci5cbiAqXG4gKiBAdGVtcGxhdGUgVCwgTSwgWFxuICogQHBhcmFtIHtUYXNrLkNvbnRyb2xsZXI8VCwgWCwgTT59IGhhbmRsZVxuICogQHBhcmFtIHtYfSBbZXJyb3JdXG4gKi9cbmV4cG9ydCBjb25zdCBhYm9ydCA9IChoYW5kbGUsIGVycm9yKSA9PiBjb25jbHVkZShoYW5kbGUsIHsgb2s6IGZhbHNlLCBlcnJvciB9KVxuXG4vKipcbiAqIEFib3J0cyBnaXZlbiB0YXNrIHdpdGggYW4gZ2l2ZW4gZXJyb3IuXG4gKlxuICogQHRlbXBsYXRlIFQsIE0sIFhcbiAqIEBwYXJhbSB7VGFzay5Db250cm9sbGVyPFQsIFgsIE0+fSBoYW5kbGVcbiAqIEBwYXJhbSB7VGFzay5SZXN1bHQ8VCwgWD59IHJlc3VsdFxuICogQHJldHVybnMge1Rhc2suVGFzazx2b2lkLCBuZXZlcj4gJiBUYXNrLkNvbnRyb2xsZXI8dm9pZCwgbmV2ZXI+fVxuICovXG5mdW5jdGlvbiogY29uY2x1ZGUoaGFuZGxlLCByZXN1bHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXNrID0gaGFuZGxlXG4gICAgY29uc3Qgc3RhdGUgPSByZXN1bHQub2tcbiAgICAgID8gdGFzay5yZXR1cm4ocmVzdWx0LnZhbHVlKVxuICAgICAgOiB0YXNrLnRocm93KHJlc3VsdC5lcnJvcilcblxuICAgIGlmICghc3RhdGUuZG9uZSkge1xuICAgICAgaWYgKHN0YXRlLnZhbHVlID09PSBTVVNQRU5EKSB7XG4gICAgICAgIGNvbnN0IHsgaWRsZSB9ID0gR3JvdXAub2YodGFzaykuc3RhY2tcbiAgICAgICAgaWRsZS5hZGQodGFzaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVucXVldWUodGFzaylcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG4vKipcbiAqIEdyb3VwcyBtdWx0aXBsZSBmb3JrcyB0b2dhdGhlciBhbmQgam9pbnMgam9pbnMgdGhlbSB3aXRoIGN1cnJlbnQgdGFzay5cbiAqXG4gKiBAdGVtcGxhdGUgVCwgWCwgTVxuICogQHBhcmFtIHtUYXNrLkZvcms8VCwgWCwgTT5bXX0gZm9ya3NcbiAqIEByZXR1cm5zIHtUYXNrLlRhc2s8dm9pZCwgWCwgTT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZ3JvdXAoZm9ya3MpIHtcbiAgLy8gQWJvcnQgZXJhbHkgaWYgdGhlcmUnc2Ugbm8gd29yayB0b2RvLlxuICBpZiAoZm9ya3MubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBjb25zdCBzZWxmID0geWllbGQqIGN1cnJlbnQoKVxuICAvKiogQHR5cGUge1Rhc2suVGFza0dyb3VwPFQsIFgsIE0+fSAqL1xuICBjb25zdCBncm91cCA9IG5ldyBHcm91cChzZWxmKVxuICAvKiogQHR5cGUge1Rhc2suRmFpbHVyZTxYPnxudWxsfSAqL1xuICBsZXQgZmFpbHVyZSA9IG51bGxcblxuICBmb3IgKGNvbnN0IGZvcmsgb2YgZm9ya3MpIHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gZm9ya1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmICghcmVzdWx0Lm9rICYmICFmYWlsdXJlKSB7XG4gICAgICAgIGZhaWx1cmUgPSByZXN1bHRcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIG1vdmUoZm9yaywgZ3JvdXApXG4gIH1cblxuICAvLyBLZWVwIHdvcmsgbG9vcGluZyB1bnRpbCB0aGVyZSBpcyBub20gbW9yZSB3b3JrIHRvIGJlIGRvbmVcbiAgdHJ5IHtcbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgdGhyb3cgZmFpbHVyZS5lcnJvclxuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB5aWVsZCogc3RlcChncm91cClcbiAgICAgIGlmIChTdGFjay5zaXplKGdyb3VwLnN0YWNrKSA+IDApIHtcbiAgICAgICAgeWllbGQqIHN1c3BlbmQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZm9yIChjb25zdCB0YXNrIG9mIGdyb3VwLnN0YWNrLmFjdGl2ZSkge1xuICAgICAgeWllbGQqIGFib3J0KHRhc2ssIGVycm9yKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdGFzayBvZiBncm91cC5zdGFjay5pZGxlKSB7XG4gICAgICB5aWVsZCogYWJvcnQodGFzaywgZXJyb3IpXG4gICAgICBlbnF1ZXVlKHRhc2spXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULCBYLCBNXG4gKiBAcGFyYW0ge1Rhc2suRm9yazxULCBYLCBNPn0gZm9ya1xuICogQHBhcmFtIHtUYXNrLlRhc2tHcm91cDxULCBYLCBNPn0gZ3JvdXBcbiAqL1xuY29uc3QgbW92ZSA9IChmb3JrLCBncm91cCkgPT4ge1xuICBjb25zdCBmcm9tID0gR3JvdXAub2YoZm9yaylcbiAgaWYgKGZyb20gIT09IGdyb3VwKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIGlkbGUgfSA9IGZyb20uc3RhY2tcbiAgICBjb25zdCB0YXJnZXQgPSBncm91cC5zdGFja1xuICAgIGZvcmsuZ3JvdXAgPSBncm91cFxuICAgIC8vIElmIGl0IGlzIGlkbGUganVzdCBtb3ZlIGZyb20gb25lIGdyb3VwIHRvIHRoZSBvdGhlclxuICAgIC8vIGFuZCB1cGRhdGUgdGhlIGdyb3VwIHRhc2sgdGhpbmtzIGl0IGJlbG9uZ3MgdG8uXG4gICAgaWYgKGlkbGUuaGFzKGZvcmspKSB7XG4gICAgICBpZGxlLmRlbGV0ZShmb3JrKVxuICAgICAgdGFyZ2V0LmlkbGUuYWRkKGZvcmspXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gYWN0aXZlLmluZGV4T2YoZm9yaylcbiAgICAgIC8vIElmIHRhc2sgaXMgaW4gdGhlIGpvYiBxdWV1ZSwgd2UgbW92ZSBpdCB0byBhIHRhcmdldCBqb2IgcXVldWUuIE1vdmluZ1xuICAgICAgLy8gdG9wIHRhc2sgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzIGV4dHJhIGNhcmUgc28gaXQgZG9lcyBub3QgZW5kIHVwXG4gICAgICAvLyBwcm9jZXNzZWQgYnkgdHdvIGdyb3VwcyB3aGljaCB3b3VsZCBsZWFkIHRvIHJhY2UuIEZvciB0aGF0IHJlYXNvblxuICAgICAgLy8gYHN0ZXBgIGxvb3AgY2hlY2tzIGZvciBncm91cCBjaGFuZ2VzIG9uIGVhY2ggdHVybi5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFjdGl2ZS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIHRhcmdldC5hY3RpdmUucHVzaChmb3JrKVxuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIHRhc2sgaXMgY29tcGxldGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgWCwgTVxuICogQHBhcmFtIHtUYXNrLkZvcms8VCwgWCwgTT59IGZvcmtcbiAqIEByZXR1cm5zIHtUYXNrLlRhc2s8VCwgWCwgTT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogam9pbihmb3JrKSB7XG4gIC8vIElmIGZvcmsgaXMgc3RpbGwgaWRsZSBhY3RpdmF0ZSBpdC5cbiAgaWYgKGZvcmsuc3RhdHVzID09PSBJRExFKSB7XG4gICAgeWllbGQqIGZvcmtcbiAgfVxuXG4gIGlmICghZm9yay5yZXN1bHQpIHtcbiAgICB5aWVsZCogZ3JvdXAoW2ZvcmtdKVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHtUYXNrLlJlc3VsdDxULCBYPn0gKi8gKGZvcmsucmVzdWx0KVxuICBpZiAocmVzdWx0Lm9rKSB7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IHJlc3VsdC5lcnJvclxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFhcbiAqIEBpbXBsZW1lbnRzIHtUYXNrLkZ1dHVyZTxULCBYPn1cbiAqL1xuY2xhc3MgRnV0dXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFzay5TdGF0ZUhhbmRsZXI8VCwgWD59IGhhbmRsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHR5cGUge1Rhc2suUmVzdWx0PFQsIFg+fHZvaWR9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHRcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1Byb21pc2U8VD59XG4gICAqL1xuICBnZXQgcHJvbWlzZSgpIHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gdGhpc1xuICAgIGNvbnN0IHByb21pc2UgPVxuICAgICAgcmVzdWx0ID09IG51bGxcbiAgICAgICAgPyBuZXcgUHJvbWlzZSgoc3VjY2VlZCwgZmFpbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9uc3VjY2VzcyA9IHN1Y2NlZWRcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vbmZhaWx1cmUgPSBmYWlsXG4gICAgICAgICAgfSlcbiAgICAgICAgOiByZXN1bHQub2tcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKVxuICAgICAgICA6IFByb21pc2UucmVqZWN0KHJlc3VsdC5lcnJvcilcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9taXNlXCIsIHsgdmFsdWU6IHByb21pc2UgfSlcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBVLCBbRT1uZXZlcl1cbiAgICogQHBhcmFtIHsoKHZhbHVlOlQpID0+IFUgfCBQcm9taXNlTGlrZTxVPil8dW5kZWZpbmVkfG51bGx9IFtvbnJlc29sdmVdXG4gICAqIEBwYXJhbSB7KChlcnJvcjpYKSA9PiBFfFByb21pc2VMaWtlPEU+KXx1bmRlZmluZWR8bnVsbH0gW29ucmVqZWN0XVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVfEU+fVxuICAgKi9cbiAgdGhlbihvbnJlc29sdmUsIG9ucmVqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGUoKS5wcm9taXNlLnRoZW4ob25yZXNvbHZlLCBvbnJlamVjdClcbiAgfVxuICAvKipcbiAgICogQHRlbXBsYXRlIFtVPW5ldmVyXVxuICAgKiBAcGFyYW0geyhlcnJvcjpYKSA9PiBVfSBvbnJlamVjdFxuICAgKi9cbiAgY2F0Y2gob25yZWplY3QpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtUYXNrLkZ1dHVyZTxUfFUsIG5ldmVyPn0gKi8gKFxuICAgICAgdGhpcy5hY3RpdmF0ZSgpLnByb21pc2UuY2F0Y2gob25yZWplY3QpXG4gICAgKVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IG9uZmluYWxseVxuICAgKiBAcmV0dXJucyB7VGFzay5GdXR1cmU8VCwgWD59XG4gICAqL1xuICBmaW5hbGx5KG9uZmluYWxseSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1Rhc2suRnV0dXJlPFQsIFg+fSAqLyAoXG4gICAgICB0aGlzLmFjdGl2YXRlKCkucHJvbWlzZS5maW5hbGx5KG9uZmluYWxseSlcbiAgICApXG4gIH1cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBhY3RpdmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFgsIE1cbiAqIEBpbXBsZW1lbnRzIHtUYXNrLkZvcms8VCwgWCwgTT59XG4gKiBAaW1wbGVtZW50cyB7VGFzay5Db250cm9sbGVyPFQsIFgsIE0+fVxuICogQGltcGxlbWVudHMge1Rhc2suVGFzazxUYXNrLkZvcms8VCwgWCwgTT4sIG5ldmVyPn1cbiAqIEBpbXBsZW1lbnRzIHtUYXNrLkZ1dHVyZTxULCBYPn1cbiAqIEBleHRlbmRzIHtGdXR1cmU8VCwgWD59XG4gKi9cbmNsYXNzIEZvcmsgZXh0ZW5kcyBGdXR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIHtUYXNrLlRhc2s8VCwgWCwgTT59IHRhc2tcbiAgICogQHBhcmFtIHtUYXNrLkZvcmtPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtUYXNrLlN0YXRlSGFuZGxlcjxULCBYPn0gW2hhbmRsZXJdXG4gICAqIEBwYXJhbSB7VGFzay5UYXNrU3RhdGU8VCwgTT59IFtzdGF0ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhc2ssIG9wdGlvbnMgPSBCTEFOSywgaGFuZGxlciA9IHt9LCBzdGF0ZSA9IElOSVQpIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuICAgIHRoaXMuaWQgPSArK0lEXG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IFwiXCJcbiAgICAvKiogQHR5cGUge1Rhc2suVGFzazxULCBYLCBNPn0gKi9cbiAgICB0aGlzLnRhc2sgPSB0YXNrXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG4gICAgdGhpcy5zdGF0dXMgPSBJRExFXG4gICAgLyoqIEB0eXBlIHtUYXNrLlJlc3VsdDxULCBYPn0gKi9cbiAgICB0aGlzLnJlc3VsdFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcblxuICAgIC8qKiBAdHlwZSB7VGFzay5Db250cm9sbGVyPFQsIFgsIE0+fSAqL1xuICAgIHRoaXMuY29udHJvbGxlclxuICB9XG5cbiAgKnJlc3VtZSgpIHtcbiAgICByZXN1bWUodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7VGFzay5UYXNrPFQsIFgsIE0+fVxuICAgKi9cbiAgam9pbigpIHtcbiAgICByZXR1cm4gam9pbih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WH0gZXJyb3JcbiAgICovXG4gIGFib3J0KGVycm9yKSB7XG4gICAgcmV0dXJuIGFib3J0KHRoaXMsIGVycm9yKVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqL1xuICBleGl0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGV4aXQodGhpcywgdmFsdWUpXG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZvcmtcIlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtUYXNrLkNvbnRyb2xsZXI8VGFzay5Gb3JrPFQsIFgsIE0+LCBuZXZlciwgbmV2ZXI+fVxuICAgKi9cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKClcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuY29udHJvbGxlciA9IHRoaXMudGFza1tTeW1ib2wuaXRlcmF0b3JdKClcbiAgICB0aGlzLnN0YXR1cyA9IEFDVElWRVxuICAgIGVucXVldWUodGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YW55fSBlcnJvclxuICAgKiBAcmV0dXJucyB7bmV2ZXJ9XG4gICAqL1xuICBwYW5pYyhlcnJvcikge1xuICAgIHRoaXMucmVzdWx0ID0geyBvazogZmFsc2UsIGVycm9yIH1cbiAgICB0aGlzLnN0YXR1cyA9IEZJTklTSEVEXG4gICAgY29uc3QgeyBoYW5kbGVyIH0gPSB0aGlzXG4gICAgaWYgKGhhbmRsZXIub25mYWlsdXJlKSB7XG4gICAgICBoYW5kbGVyLm9uZmFpbHVyZShlcnJvcilcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VGFzay5UYXNrU3RhdGU8VCwgTT59IHN0YXRlXG4gICAqL1xuICBzdGVwKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG4gICAgaWYgKHN0YXRlLmRvbmUpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0geyBvazogdHJ1ZSwgdmFsdWU6IHN0YXRlLnZhbHVlIH1cbiAgICAgIHRoaXMuc3RhdHVzID0gRklOSVNIRURcbiAgICAgIGNvbnN0IHsgaGFuZGxlciB9ID0gdGhpc1xuICAgICAgaWYgKGhhbmRsZXIub25zdWNjZXNzKSB7XG4gICAgICAgIGhhbmRsZXIub25zdWNjZXNzKHN0YXRlLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAgICovXG4gIG5leHQodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RlcCh0aGlzLmNvbnRyb2xsZXIubmV4dCh2YWx1ZSkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbmljKGVycm9yKVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKi9cbiAgcmV0dXJuKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZXAodGhpcy5jb250cm9sbGVyLnJldHVybih2YWx1ZSkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbmljKGVycm9yKVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtYfSBlcnJvclxuICAgKi9cbiAgdGhyb3coZXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RlcCh0aGlzLmNvbnRyb2xsZXIudGhyb3coZXJyb3IpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5pYyhlcnJvcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgTVxuICogQHBhcmFtIHtUYXNrLkVmZmVjdDxNPn0gaW5pdFxuICogQHBhcmFtIHsobWVzc2FnZTpNKSA9PiBUYXNrLkVmZmVjdDxNPn0gbmV4dFxuICogQHJldHVybnMge1Rhc2suVGFzazx2b2lkLCBuZXZlciwgbmV2ZXI+fVxuICovXG5leHBvcnQgY29uc3QgbG9vcCA9IGZ1bmN0aW9uKiAoaW5pdCwgbmV4dCkge1xuICAvKiogQHR5cGUge1Rhc2suQ29udHJvbGxlcjx2b2lkLCBuZXZlciwgTT59ICovXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSB5aWVsZCogY3VycmVudCgpXG4gIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKGNvbnRyb2xsZXIpXG4gIEdyb3VwLmVucXVldWUoaW5pdFtTeW1ib2wuaXRlcmF0b3JdKCksIGdyb3VwKVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHN0ZXAoZ3JvdXApKSB7XG4gICAgICBHcm91cC5lbnF1ZXVlKG5leHQobWVzc2FnZSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBncm91cClcbiAgICB9XG5cbiAgICBpZiAoU3RhY2suc2l6ZShncm91cC5zdGFjaykgPiAwKSB7XG4gICAgICB5aWVsZCogc3VzcGVuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmxldCBJRCA9IDBcbi8qKiBAdHlwZSB7VGFzay5TdGF0dXN9ICovXG5jb25zdCBJRExFID0gXCJpZGxlXCJcbmNvbnN0IEFDVElWRSA9IFwiYWN0aXZlXCJcbmNvbnN0IEZJTklTSEVEID0gXCJmaW5pc2hlZFwiXG4vKiogQHR5cGUge1Rhc2suVGFza1N0YXRlPGFueSwgYW55Pn0gKi9cbmNvbnN0IElOSVQgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogQ1VSUkVOVCB9XG5cbmNvbnN0IEJMQU5LID0ge31cblxuLyoqIEB0eXBlIHtUYXNrLkVmZmVjdDxuZXZlcj59ICovXG5jb25zdCBOT05FID0gKGZ1bmN0aW9uKiBub25lKCkge30pKClcblxuLyoqIEB0eXBlIHtUYXNrLk1haW48YW55LCBhbnksIGFueT59ICovXG5jb25zdCBNQUlOID0gbmV3IE1haW4oKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/actor/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/actor/src/task.js":
/*!****************************************!*\
  !*** ./node_modules/actor/src/task.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abort: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.abort),\n/* harmony export */   all: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.all),\n/* harmony export */   batch: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.batch),\n/* harmony export */   current: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.current),\n/* harmony export */   effect: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.effect),\n/* harmony export */   effects: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.effects),\n/* harmony export */   exit: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.exit),\n/* harmony export */   fork: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.fork),\n/* harmony export */   group: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.group),\n/* harmony export */   isInstruction: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.isInstruction),\n/* harmony export */   isMessage: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   join: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.join),\n/* harmony export */   listen: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.listen),\n/* harmony export */   loop: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.loop),\n/* harmony export */   main: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.main),\n/* harmony export */   none: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.none),\n/* harmony export */   resume: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.resume),\n/* harmony export */   send: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.send),\n/* harmony export */   sleep: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.sleep),\n/* harmony export */   spawn: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.spawn),\n/* harmony export */   suspend: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.suspend),\n/* harmony export */   tag: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.tag),\n/* harmony export */   terminate: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.terminate),\n/* harmony export */   then: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.then),\n/* harmony export */   wait: () => (/* reexport safe */ _lib_js__WEBPACK_IMPORTED_MODULE_0__.wait)\n/* harmony export */ });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ \"(ssr)/./node_modules/actor/src/lib.js\");\n// This is file is only here to allow importing type namespace\n// from JS.\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWN0b3Ivc3JjL3Rhc2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvYWN0b3Ivc3JjL3Rhc2suanM/ODYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGlzIGZpbGUgaXMgb25seSBoZXJlIHRvIGFsbG93IGltcG9ydGluZyB0eXBlIG5hbWVzcGFjZVxuLy8gZnJvbSBKUy5cbmV4cG9ydCAqIGZyb20gXCIuL2xpYi5qc1wiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/actor/src/task.js\n");

/***/ })

};
;