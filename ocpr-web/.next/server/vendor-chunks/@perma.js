"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@perma";
exports.ids = ["vendor-chunks/@perma"];
exports.modules = {

/***/ "(ssr)/./node_modules/@perma/map/node_modules/@multiformats/murmur3/src/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/@multiformats/murmur3/src/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   murmur3128: () => (/* binding */ murmur3128),\n/* harmony export */   murmur332: () => (/* binding */ murmur332),\n/* harmony export */   murmur364: () => (/* binding */ murmur364)\n/* harmony export */ });\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/index.js\");\n/* harmony import */ var multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/hashes/hasher */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/hasher.js\");\n/* harmony import */ var murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! murmurhash3js-revisited */ \"(ssr)/./node_modules/murmurhash3js-revisited/index.js\");\n\n\n// @ts-expect-error no types\n\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nconst murmur332 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x86.hash32(input))\n})\n\nconst murmur3128 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => multiformats__WEBPACK_IMPORTED_MODULE_0__.bytes.fromHex(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nconst murmur364 = (0,multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => multiformats__WEBPACK_IMPORTED_MODULE_0__.bytes.fromHex(murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_2__.x64.hash128(input)).subarray(0, 8)\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvQG11bHRpZm9ybWF0cy9tdXJtdXIzL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDYTtBQUNqRDtBQUN5Qzs7QUFFekM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sa0JBQWtCLGdFQUFJO0FBQzdCO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQU87QUFDakQsQ0FBQzs7QUFFTSxtQkFBbUIsZ0VBQUk7QUFDOUI7QUFDQTtBQUNBLHFCQUFxQix1REFBYSxDQUFDLHdEQUFPO0FBQzFDLENBQUM7O0FBRUQ7QUFDTyxrQkFBa0IsZ0VBQUk7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQix1REFBYSxDQUFDLHdEQUFPO0FBQzFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211cm11cjMvc3JjL2luZGV4LmpzPzM1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXMgfSBmcm9tICdtdWx0aWZvcm1hdHMnXG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9oYXNoZXInXG4vLyBAdHMtZXhwZWN0LWVycm9yIG5vIHR5cGVzXG5pbXBvcnQgbXVyIGZyb20gJ211cm11cmhhc2gzanMtcmV2aXNpdGVkJ1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBmcm9tTnVtYmVyVG8zMkJpdEJ1ZiAobnVtYmVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KDQpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBudW1iZXIgJiAweGZmXG4gICAgbnVtYmVyID0gbnVtYmVyID4+IDhcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG59XG5cbmV4cG9ydCBjb25zdCBtdXJtdXIzMzIgPSBmcm9tKHtcbiAgbmFtZTogJ211cm11cjMtMzInLFxuICBjb2RlOiAweDIzLFxuICBlbmNvZGU6IChpbnB1dCkgPT4gZnJvbU51bWJlclRvMzJCaXRCdWYobXVyLng4Ni5oYXNoMzIoaW5wdXQpKVxufSlcblxuZXhwb3J0IGNvbnN0IG11cm11cjMxMjggPSBmcm9tKHtcbiAgbmFtZTogJ211cm11cjMtMTI4JyxcbiAgY29kZTogMHgyMixcbiAgZW5jb2RlOiAoaW5wdXQpID0+IGJ5dGVzLmZyb21IZXgobXVyLng2NC5oYXNoMTI4KGlucHV0KSlcbn0pXG5cbi8vIEEgc3BlY2lhbC11c2UgMHgyMiB0aGF0IHRydW5jYXRlcyA2NCBiaXRzLCBzcGVjaWZpY2FsbHkgZm9yIHVzZSBpbiB0aGUgVW5peEZTIEhBTVRcbmV4cG9ydCBjb25zdCBtdXJtdXIzNjQgPSBmcm9tKHtcbiAgbmFtZTogJ211cm11cjMteDY0LTY0JyxcbiAgY29kZTogMHgyMixcbiAgZW5jb2RlOiAoaW5wdXQpID0+IGJ5dGVzLmZyb21IZXgobXVyLng2NC5oYXNoMTI4KGlucHV0KSkuc3ViYXJyYXkoMCwgOClcbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/@multiformats/murmur3/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Codec: () => (/* binding */ Codec),\n/* harmony export */   baseX: () => (/* binding */ baseX),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   rfc4648: () => (/* binding */ rfc4648)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/base-x.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/base-x.js\");\n\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        const prefixCodePoint = prefix.codePointAt(0);\n        /* c8 ignore next 3 */\n        if (prefixCodePoint === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefixCodePoint;\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nfunction or(left, right) {\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nclass Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nfunction from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nfunction baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(decode(text))\n    });\n}\nfunction decode(string, alphabetIdx, bitsPerChar, name) {\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = alphabetIdx[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\nfunction createAlphabetIdx(alphabet) {\n    // Build the character lookup table:\n    const alphabetIdx = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        alphabetIdx[alphabet[i]] = i;\n    }\n    return alphabetIdx;\n}\n/**\n * RFC4648 Factory\n */\nfunction rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    const alphabetIdx = createAlphabetIdx(alphabet);\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabetIdx, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxQztBQUNHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksRUFBRSx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFCQUFxQixJQUFJLFdBQVcsNkNBQTZDLFlBQVk7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxzQkFBc0IsOEJBQThCLDRCQUE0QjtBQUNsSjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRCxnQ0FBZ0MsdUJBQXVCO0FBQ3ZELEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0JBQWdCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ08saUJBQWlCLHdCQUF3QjtBQUNoRCxZQUFZLGlCQUFpQixFQUFFLDZEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFNO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2UuanM/NzA0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuLi9ieXRlcy5qcyc7XG5pbXBvcnQgYmFzZXggZnJvbSAnLi4vdmVuZG9yL2Jhc2UteC5qcyc7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudHMgYm90aCBCYXNlRW5jb2RlciBhbmQgTXVsdGliYXNlRW5jb2RlciBtZWFuaW5nIGl0XG4gKiBjYW4gYmUgdXNlZCB0byBlbmNvZGUgdG8gbXVsdGliYXNlIG9yIGJhc2UgZW5jb2RlIHdpdGhvdXQgbXVsdGliYXNlXG4gKiBwcmVmaXguXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICAgIG5hbWU7XG4gICAgcHJlZml4O1xuICAgIGJhc2VFbmNvZGU7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlO1xuICAgIH1cbiAgICBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dGhpcy5iYXNlRW5jb2RlKGJ5dGVzKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRzIGJvdGggQmFzZURlY29kZXIgYW5kIE11bHRpYmFzZURlY29kZXIgc28gaXQgY291bGQgYmUgdXNlZFxuICogdG8gZGVjb2RlIG11bHRpYmFzZXMgKHdpdGggbWF0Y2hpbmcgcHJlZml4KSBvciBqdXN0IGJhc2UgZGVjb2RlIHN0cmluZ3NcbiAqIHdpdGggY29ycmVzcG9uZGluZyBiYXNlIGVuY29kaW5nLlxuICovXG5jbGFzcyBEZWNvZGVyIHtcbiAgICBuYW1lO1xuICAgIHByZWZpeDtcbiAgICBiYXNlRGVjb2RlO1xuICAgIHByZWZpeENvZGVQb2ludDtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VEZWNvZGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIGNvbnN0IHByZWZpeENvZGVQb2ludCA9IHByZWZpeC5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgICAgICBpZiAocHJlZml4Q29kZVBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSBwcmVmaXhDb2RlUG9pbnQ7XG4gICAgICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gICAgfVxuICAgIGRlY29kZSh0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeSh0ZXh0KX0sICR7dGhpcy5uYW1lfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHt0aGlzLnByZWZpeH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUodGV4dC5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW4gb25seSBtdWx0aWJhc2UgZGVjb2RlIHN0cmluZ3MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcihkZWNvZGVyKSB7XG4gICAgICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NlZERlY29kZXIge1xuICAgIGRlY29kZXJzO1xuICAgIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlcnMgPSBkZWNvZGVycztcbiAgICB9XG4gICAgb3IoZGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gICAgfVxuICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBpbnB1dFswXTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICAgICAgaWYgKGRlY29kZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGlucHV0KX0sIG9ubHkgaW5wdXRzIHByZWZpeGVkIHdpdGggJHtPYmplY3Qua2V5cyh0aGlzLmRlY29kZXJzKX0gYXJlIHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb3NlZERlY29kZXIoe1xuICAgICAgICAuLi4obGVmdC5kZWNvZGVycyA/PyB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSksXG4gICAgICAgIC4uLihyaWdodC5kZWNvZGVycyA/PyB7IFtyaWdodC5wcmVmaXhdOiByaWdodCB9KVxuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIENvZGVjIHtcbiAgICBuYW1lO1xuICAgIHByZWZpeDtcbiAgICBiYXNlRW5jb2RlO1xuICAgIGJhc2VEZWNvZGU7XG4gICAgZW5jb2RlcjtcbiAgICBkZWNvZGVyO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSwgYmFzZURlY29kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgICAgICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKTtcbiAgICB9XG4gICAgZW5jb2RlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5jb2RlKGlucHV0KTtcbiAgICB9XG4gICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbSh7IG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUgfSkge1xuICAgIHJldHVybiBuZXcgQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYmFzZVgoeyBuYW1lLCBwcmVmaXgsIGFscGhhYmV0IH0pIHtcbiAgICBjb25zdCB7IGVuY29kZSwgZGVjb2RlIH0gPSBiYXNleChhbHBoYWJldCwgbmFtZSk7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgZGVjb2RlOiAodGV4dCkgPT4gY29lcmNlKGRlY29kZSh0ZXh0KSlcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGFscGhhYmV0SWR4LCBiaXRzUGVyQ2hhciwgbmFtZSkge1xuICAgIC8vIENvdW50IHRoZSBwYWRkaW5nIGJ5dGVzOlxuICAgIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgICAgICAtLWVuZDtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgdGhlIG91dHB1dDpcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApO1xuICAgIC8vIFBhcnNlIHRoZSBkYXRhOlxuICAgIGxldCBiaXRzID0gMDsgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgICBsZXQgYnVmZmVyID0gMDsgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgICBsZXQgd3JpdHRlbiA9IDA7IC8vIE5leHQgYnl0ZSB0byB3cml0ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgLy8gUmVhZCBvbmUgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmluZzpcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhbHBoYWJldElkeFtzdHJpbmdbaV1dO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHtuYW1lfSBjaGFyYWN0ZXJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICAgICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZTtcbiAgICAgICAgYml0cyArPSBiaXRzUGVyQ2hhcjtcbiAgICAgICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICAgICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgICAgICAgYml0cyAtPSA4O1xuICAgICAgICAgICAgb3V0W3dyaXR0ZW4rK10gPSAweGZmICYgKGJ1ZmZlciA+PiBiaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gICAgaWYgKGJpdHMgPj0gYml0c1BlckNoYXIgfHwgKDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGVuY29kZShkYXRhLCBhbHBoYWJldCwgYml0c1BlckNoYXIpIHtcbiAgICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICAgIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxO1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBsZXQgYml0cyA9IDA7IC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gICAgbGV0IGJ1ZmZlciA9IDA7IC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXTtcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICAgICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPj4gYml0cyldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICAgIGlmIChiaXRzICE9PSAwKSB7XG4gICAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldO1xuICAgIH1cbiAgICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gICAgaWYgKHBhZCkge1xuICAgICAgICB3aGlsZSAoKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykgIT09IDApIHtcbiAgICAgICAgICAgIG91dCArPSAnPSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFscGhhYmV0SWR4KGFscGhhYmV0KSB7XG4gICAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gICAgY29uc3QgYWxwaGFiZXRJZHggPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFscGhhYmV0SWR4W2FscGhhYmV0W2ldXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBhbHBoYWJldElkeDtcbn1cbi8qKlxuICogUkZDNDY0OCBGYWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZmM0NjQ4KHsgbmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXQgfSkge1xuICAgIGNvbnN0IGFscGhhYmV0SWR4ID0gY3JlYXRlQWxwaGFiZXRJZHgoYWxwaGFiZXQpO1xuICAgIHJldHVybiBmcm9tKHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBuYW1lLFxuICAgICAgICBlbmNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXRJZHgsIGJpdHNQZXJDaGFyLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base32.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base32.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexpad: () => (/* binding */ base32hexpad),\n/* harmony export */   base32hexpadupper: () => (/* binding */ base32hexpadupper),\n/* harmony export */   base32hexupper: () => (/* binding */ base32hexupper),\n/* harmony export */   base32pad: () => (/* binding */ base32pad),\n/* harmony export */   base32padupper: () => (/* binding */ base32padupper),\n/* harmony export */   base32upper: () => (/* binding */ base32upper),\n/* harmony export */   base32z: () => (/* binding */ base32z)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nconst base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nconst base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nconst base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nconst base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nconst base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nconst base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nconst base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nconst base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQzdCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sb0JBQW9CLGlEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSx1QkFBdUIsaURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLHVCQUF1QixpREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxxQkFBcUIsaURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sMEJBQTBCLGlEQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLGdCQUFnQixpREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9iYXNlcy9iYXNlMzIuanM/NmEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlMzIgPSByZmM0NjQ4KHtcbiAgICBwcmVmaXg6ICdiJyxcbiAgICBuYW1lOiAnYmFzZTMyJyxcbiAgICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3JyxcbiAgICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMydXBwZXIgPSByZmM0NjQ4KHtcbiAgICBwcmVmaXg6ICdCJyxcbiAgICBuYW1lOiAnYmFzZTMydXBwZXInLFxuICAgIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnLFxuICAgIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJwYWQgPSByZmM0NjQ4KHtcbiAgICBwcmVmaXg6ICdjJyxcbiAgICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PScsXG4gICAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMnBhZHVwcGVyID0gcmZjNDY0OCh7XG4gICAgcHJlZml4OiAnQycsXG4gICAgbmFtZTogJ2Jhc2UzMnBhZHVwcGVyJyxcbiAgICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PScsXG4gICAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IHJmYzQ2NDgoe1xuICAgIHByZWZpeDogJ3YnLFxuICAgIG5hbWU6ICdiYXNlMzJoZXgnLFxuICAgIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnLFxuICAgIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXh1cHBlciA9IHJmYzQ2NDgoe1xuICAgIHByZWZpeDogJ1YnLFxuICAgIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gICAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicsXG4gICAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleHBhZCA9IHJmYzQ2NDgoe1xuICAgIHByZWZpeDogJ3QnLFxuICAgIG5hbWU6ICdiYXNlMzJoZXhwYWQnLFxuICAgIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9JyxcbiAgICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgICBwcmVmaXg6ICdUJyxcbiAgICBuYW1lOiAnYmFzZTMyaGV4cGFkdXBwZXInLFxuICAgIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9JyxcbiAgICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyeiA9IHJmYzQ2NDgoe1xuICAgIHByZWZpeDogJ2gnLFxuICAgIG5hbWU6ICdiYXNlMzJ6JyxcbiAgICBhbHBoYWJldDogJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5JyxcbiAgICBiaXRzUGVyQ2hhcjogNVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlMzIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base36.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base36.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base36: () => (/* binding */ base36),\n/* harmony export */   base36upper: () => (/* binding */ base36upper)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nconst base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2UzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDM0IsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sb0JBQW9CLCtDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9iYXNlcy9iYXNlMzYuanM/OWU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTM2ID0gYmFzZVgoe1xuICAgIHByZWZpeDogJ2snLFxuICAgIG5hbWU6ICdiYXNlMzYnLFxuICAgIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xufSk7XG5leHBvcnQgY29uc3QgYmFzZTM2dXBwZXIgPSBiYXNlWCh7XG4gICAgcHJlZml4OiAnSycsXG4gICAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWidcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTM2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base36.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base58.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base58.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58btc: () => (/* binding */ base58btc),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nconst base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDM0Isa0JBQWtCLCtDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxxQkFBcUIsK0NBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2Jhc2U1OC5qcz9kNTZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJhc2VYIH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlNThidGMgPSBiYXNlWCh7XG4gICAgbmFtZTogJ2Jhc2U1OGJ0YycsXG4gICAgcHJlZml4OiAneicsXG4gICAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xufSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gYmFzZVgoe1xuICAgIG5hbWU6ICdiYXNlNThmbGlja3InLFxuICAgIHByZWZpeDogJ1onLFxuICAgIGFscGhhYmV0OiAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWidcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/interface.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/interface.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Base encoders / decoders just base encode / decode between binary and\n// textual representation. They are unaware of multibase.\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jhc2VzL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZGlzdC9zcmMvYmFzZXMvaW50ZXJmYWNlLmpzPzEzYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFzZSBlbmNvZGVycyAvIGRlY29kZXJzIGp1c3QgYmFzZSBlbmNvZGUgLyBkZWNvZGUgYmV0d2VlbiBiaW5hcnkgYW5kXG4vLyB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLiBUaGV5IGFyZSB1bmF3YXJlIG9mIG11bHRpYmFzZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/block/interface.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/block/interface.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2Jsb2NrL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9ibG9jay9pbnRlcmZhY2UuanM/MWM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/block/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isBinary: () => (/* binding */ isBinary),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\nconst empty = new Uint8Array(0);\nfunction toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nfunction fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nfunction equals(aa, bb) {\n    if (aa === bb) {\n        return true;\n    }\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') {\n        return o;\n    }\n    if (o instanceof ArrayBuffer) {\n        return new Uint8Array(o);\n    }\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nfunction isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nfunction fromString(str) {\n    return new TextEncoder().encode(str);\n}\nfunction toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQU87QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9ieXRlcy5qcz8zMDhhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KDApO1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KGQpIHtcbiAgICByZXR1cm4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgY29uc3QgaGV4ZXMgPSBoZXgubWF0Y2goLy4uL2cpO1xuICAgIHJldHVybiBoZXhlcyAhPSBudWxsID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYWEsIGJiKSB7XG4gICAgaWYgKGFhID09PSBiYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFhLmJ5dGVMZW5ndGggIT09IGJiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYWEuYnl0ZUxlbmd0aDsgaWkrKykge1xuICAgICAgICBpZiAoYWFbaWldICE9PSBiYltpaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2Uobykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jykge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgaWYgKG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobyk7XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcobykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCaW5hcnkobykge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGIpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/cid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/cid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID: () => (/* binding */ CID),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   fromJSON: () => (/* binding */ fromJSON),\n/* harmony export */   toJSON: () => (/* binding */ toJSON)\n/* harmony export */ });\n/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/base32.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base32.js\");\n/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base36.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base36.js\");\n/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base58.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashes/digest.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./varint.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js\");\n/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./link/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/link/interface.js\");\n\n\n\n\n\n\n// This way TS will also expose all the types from module\n\nfunction format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.encoder));\n    }\n}\nfunction toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nfunction fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nclass CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_3__.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_5__.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;\n            return [\n                _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix,\n                decoder.decode(`${_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix}${source}`)\n            ];\n        }\n        case _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix: {\n            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;\n            return [_bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix, decoder.decode(source)];\n        }\n        case _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix: {\n            const decoder = base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32;\n            return [_bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix, decoder.decode(source)];\n        }\n        case _bases_base36_js__WEBPACK_IMPORTED_MODULE_1__.base36.prefix: {\n            const decoder = base ?? _bases_base36_js__WEBPACK_IMPORTED_MODULE_1__.base36;\n            return [_bases_base36_js__WEBPACK_IMPORTED_MODULE_1__.base36.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_5__.encodingLength(version);\n    const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_5__.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    _varint_js__WEBPACK_IMPORTED_MODULE_5__.encodeTo(version, bytes, 0);\n    _varint_js__WEBPACK_IMPORTED_MODULE_5__.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2NpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNBO0FBQ0c7QUFDVjtBQUNTO0FBQ1A7QUFDdEM7QUFDb0M7QUFDN0I7QUFDUCxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0EsOERBQThELHVEQUFTO0FBQ3ZFO0FBQ0EsK0RBQStELG9EQUFNO0FBQ3JFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QyxrQ0FBa0MscURBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQywyQkFBMkIscURBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQVM7QUFDN0M7QUFDQSxnQkFBZ0IsdURBQVM7QUFDekIsa0NBQWtDLHVEQUFTLFFBQVEsRUFBRSxPQUFPO0FBQzVEO0FBQ0E7QUFDQSxhQUFhLHVEQUFTO0FBQ3RCLG9DQUFvQyx1REFBUztBQUM3QyxvQkFBb0IsdURBQVM7QUFDN0I7QUFDQSxhQUFhLG9EQUFNO0FBQ25CLG9DQUFvQyxvREFBTTtBQUMxQyxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQSxhQUFhLG9EQUFNO0FBQ25CLG9DQUFvQyxvREFBTTtBQUMxQyxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsbUJBQW1CLHVEQUFTO0FBQzVCLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBcUI7QUFDNUMsb0NBQW9DLHNEQUFxQjtBQUN6RDtBQUNBLElBQUksZ0RBQWU7QUFDbkIsSUFBSSxnREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2NpZC5qcz8xMzBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJhc2UzMiB9IGZyb20gJy4vYmFzZXMvYmFzZTMyLmpzJztcbmltcG9ydCB7IGJhc2UzNiB9IGZyb20gJy4vYmFzZXMvYmFzZTM2LmpzJztcbmltcG9ydCB7IGJhc2U1OGJ0YyB9IGZyb20gJy4vYmFzZXMvYmFzZTU4LmpzJztcbmltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4vYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcyc7XG5pbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi92YXJpbnQuanMnO1xuLy8gVGhpcyB3YXkgVFMgd2lsbCBhbHNvIGV4cG9zZSBhbGwgdGhlIHR5cGVzIGZyb20gbW9kdWxlXG5leHBvcnQgKiBmcm9tICcuL2xpbmsvaW50ZXJmYWNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQobGluaywgYmFzZSkge1xuICAgIGNvbnN0IHsgYnl0ZXMsIHZlcnNpb24gfSA9IGxpbms7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZ1YwKGJ5dGVzLCBiYXNlQ2FjaGUobGluayksIGJhc2UgPz8gYmFzZTU4YnRjLmVuY29kZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nVjEoYnl0ZXMsIGJhc2VDYWNoZShsaW5rKSwgKGJhc2UgPz8gYmFzZTMyLmVuY29kZXIpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9KU09OKGxpbmspIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAnLyc6IGZvcm1hdChsaW5rKVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgIHJldHVybiBDSUQucGFyc2UoanNvblsnLyddKTtcbn1cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGJhc2VDYWNoZShjaWQpIHtcbiAgICBjb25zdCBiYXNlQ2FjaGUgPSBjYWNoZS5nZXQoY2lkKTtcbiAgICBpZiAoYmFzZUNhY2hlID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgYmFzZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBjYWNoZS5zZXQoY2lkLCBiYXNlQ2FjaGUpO1xuICAgICAgICByZXR1cm4gYmFzZUNhY2hlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUNhY2hlO1xufVxuZXhwb3J0IGNsYXNzIENJRCB7XG4gICAgY29kZTtcbiAgICB2ZXJzaW9uO1xuICAgIG11bHRpaGFzaDtcbiAgICBieXRlcztcbiAgICAnLyc7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBDSURcbiAgICAgKiBAcGFyYW0gY29kZSAtIENvZGUgb2YgdGhlIGNvZGVjIGNvbnRlbnQgaXMgZW5jb2RlZCBpbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGljb2RlYy9ibG9iL21hc3Rlci90YWJsZS5jc3ZcbiAgICAgKiBAcGFyYW0gbXVsdGloYXNoIC0gKE11bHRpKWhhc2ggb2YgdGhlIG9mIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWhhc2g7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgLy8gZmxhZyB0byBzZXJpYWxpemVycyB0aGF0IHRoaXMgaXMgYSBDSUQgYW5kXG4gICAgICAgIC8vIHNob3VsZCBiZSB0cmVhdGVkIHNwZWNpYWxseVxuICAgICAgICB0aGlzWycvJ10gPSBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsbGluZyBgY2lkLmFzQ0lEID09PSBjaWRgIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYGNpZFsnLyddID09PSBjaWQuYnl0ZXNgXG4gICAgICogcGxlYXNlIGVpdGhlciB1c2UgYENJRC5hc0NJRChjaWQpYCBvciBzd2l0Y2ggdG8gbmV3IHNpZ25hbGxpbmcgbWVjaGFuaXNtXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBhc0NJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFycmF5QnVmZmVyVmlld1xuICAgIGdldCBieXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlT2Zmc2V0O1xuICAgIH1cbiAgICAvLyBBcnJheUJ1ZmZlclZpZXdcbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdG9WMCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBtdWx0aWhhc2ggfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IERBR19QQl9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaGEyLTI1NlxuICAgICAgICAgICAgICAgIGlmIChtdWx0aWhhc2guY29kZSAhPT0gU0hBXzI1Nl9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChDSUQuY3JlYXRlVjAobXVsdGloYXNoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENhbiBub3QgY29udmVydCBDSUQgdmVyc2lvbiAke3RoaXMudmVyc2lvbn0gdG8gdmVyc2lvbiAwLiBUaGlzIGlzIGEgYnVnIHBsZWFzZSByZXBvcnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1YxKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkaWdlc3QgfSA9IHRoaXMubXVsdGloYXNoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpaGFzaCA9IERpZ2VzdC5jcmVhdGUoY29kZSwgZGlnZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKENJRC5jcmVhdGVWMSh0aGlzLmNvZGUsIG11bHRpaGFzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENhbiBub3QgY29udmVydCBDSUQgdmVyc2lvbiAke3RoaXMudmVyc2lvbn0gdG8gdmVyc2lvbiAxLiBUaGlzIGlzIGEgYnVnIHBsZWFzZSByZXBvcnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIENJRC5lcXVhbHModGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKHNlbGYsIG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHVua25vd24gPSBvdGhlcjtcbiAgICAgICAgcmV0dXJuICh1bmtub3duICE9IG51bGwgJiZcbiAgICAgICAgICAgIHNlbGYuY29kZSA9PT0gdW5rbm93bi5jb2RlICYmXG4gICAgICAgICAgICBzZWxmLnZlcnNpb24gPT09IHVua25vd24udmVyc2lvbiAmJlxuICAgICAgICAgICAgRGlnZXN0LmVxdWFscyhzZWxmLm11bHRpaGFzaCwgdW5rbm93bi5tdWx0aWhhc2gpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoYmFzZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGJhc2UpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICcvJzogZm9ybWF0KHRoaXMpIH07XG4gICAgfVxuICAgIGxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdDSUQnO1xuICAgIC8vIExlZ2FjeVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBDSUQoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGFueSBpbnB1dCBgdmFsdWVgIGFuZCByZXR1cm5zIGEgYENJRGAgaW5zdGFuY2UgaWYgaXQgd2FzXG4gICAgICogYSBgQ0lEYCBvdGhlcndpc2UgcmV0dXJucyBgbnVsbGAuIElmIGB2YWx1ZWAgaXMgaW5zdGFuY2VvZiBgQ0lEYFxuICAgICAqIGl0IHdpbGwgcmV0dXJuIHZhbHVlIGJhY2suIElmIGB2YWx1ZWAgaXMgbm90IGluc3RhbmNlIG9mIHRoaXMgQ0lEXG4gICAgICogY2xhc3MsIGJ1dCBpcyBjb21wYXRpYmxlIENJRCBpdCB3aWxsIHJldHVybiBuZXcgaW5zdGFuY2Ugb2YgdGhpc1xuICAgICAqIGBDSURgIGNsYXNzLiBPdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgdHdvIGRpZmZlcmVudCBpbmNvbXBhdGlibGUgdmVyc2lvbnMgb2YgQ0lEIGxpYnJhcnkgdG9cbiAgICAgKiBjby1leGlzdCBhbmQgaW50ZXJvcCBhcyBsb25nIGFzIGJpbmFyeSBpbnRlcmZhY2UgaXMgY29tcGF0aWJsZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXNDSUQoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQ7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENJRCkge1xuICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgaW5zdGFuY2Ugb2YgQ0lEIHRoZW4gd2UncmUgYWxsIHNldC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmFsdWVbJy8nXSAhPSBudWxsICYmIHZhbHVlWycvJ10gPT09IHZhbHVlLmJ5dGVzKSB8fCB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzbid0IGluc3RhbmNlIG9mIHRoaXMgQ0lEIGNsYXNzIGJ1dCBgdGhpcy5hc0NJRCA9PT0gdGhpc2Agb3JcbiAgICAgICAgICAgIC8vIGB2YWx1ZVsnLyddID09PSB2YWx1ZS5ieXRlc2AgaXMgdHJ1ZSBpdCBpcyBDSUQgaW5zdGFuY2UgY29taW5nIGZyb20gYVxuICAgICAgICAgICAgLy8gZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIChkaWZmIHZlcnNpb24gb3IgZHVwbGljYXRlKS4gSW4gdGhhdCBjYXNlIHdlXG4gICAgICAgICAgICAvLyByZWJhc2UgaXQgdG8gdGhpcyBgQ0lEYCBpbXBsZW1lbnRhdGlvbiBzbyBjYWxsZXIgaXMgZ3VhcmFudGVlZCB0byBnZXRcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIHdpdGggZXhwZWN0ZWQgQVBJLlxuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMgPz8gZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlW2NpZFN5bWJvbF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgQ0lEIGZyb20gb2xkZXIgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VkIHRvIGJlIHRhZ2dlZCB2aWFcbiAgICAgICAgICAgIC8vIHN5bWJvbCB3ZSBzdGlsbCByZWJhc2UgaXQgdG8gdGhlIHRoaXMgYENJRGAgaW1wbGVtZW50YXRpb24gYnlcbiAgICAgICAgICAgIC8vIGRlbGVnYXRpbmcgdGhhdCB0byBhIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBtdWx0aWhhc2gsIGNvZGUgfSA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gRGlnZXN0LmRlY29kZShtdWx0aWhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIENJRC5jcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB2YWx1ZSBpcyBub3QgYSBDSUQgKG9yIGFuIGluY29tcGF0aWJsZSB2ZXJzaW9uIG9mIGl0KSBpblxuICAgICAgICAgICAgLy8gd2hpY2ggY2FzZSB3ZSByZXR1cm4gYG51bGxgLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBDSURcbiAgICAgKiBAcGFyYW0gY29kZSAtIENvZGUgb2YgdGhlIGNvZGVjIGNvbnRlbnQgaXMgZW5jb2RlZCBpbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGljb2RlYy9ibG9iL21hc3Rlci90YWJsZS5jc3ZcbiAgICAgKiBAcGFyYW0gZGlnZXN0IC0gKE11bHRpKWhhc2ggb2YgdGhlIG9mIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIGNvZGVjcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGRpZ2VzdC5ieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlnZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWZXJzaW9uIDAgQ0lEIG11c3QgdXNlIGRhZy1wYiAoY29kZTogJHtEQUdfUEJfQ09ERX0pIGJsb2NrIGVuY29kaW5nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGRpZ2VzdC5ieXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgY3JlYXRlYCBmb3IgQ0lEdjAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVYwKGRpZ2VzdCkge1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBjcmVhdGVgIGZvciBDSUR2MS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIC0gQ29udGVudCBlbmNvZGluZyBmb3JtYXQgY29kZS5cbiAgICAgKiBAcGFyYW0gZGlnZXN0IC0gTXVsdGloYXNoIG9mIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVWMShjb2RlLCBkaWdlc3QpIHtcbiAgICAgICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlZCBhIENJRCBmcm9tIGl0cyBiaW5hcnkgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlIGFycmF5IG11c3QgY29udGFpblxuICAgICAqIG9ubHkgdGhlIENJRCB3aXRoIG5vIGFkZGl0aW9uYWwgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBBbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB0aGUgYnl0ZXMgcHJvdmlkZWQgZG8gbm90IGNvbnRhaW4gYSB2YWxpZFxuICAgICAqIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIENJRC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IFtjaWQsIHJlbWFpbmRlcl0gPSBDSUQuZGVjb2RlRmlyc3QoYnl0ZXMpO1xuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlZCBhIENJRCBmcm9tIGl0cyBiaW5hcnkgcmVwcmVzZW50YXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiBhIGJ5dGVcbiAgICAgKiBhcnJheS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluaW5nIHRoZSBDSUQgYW5kIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHJlbWFpbmRlciBvZiB0aGUgb3JpZ2luYWwgYnl0ZSBhcnJheS4gVGhlIHJlbWFpbmRlclxuICAgICAqIHdpbGwgYmUgYSB6ZXJvLWxlbmd0aCBieXRlIGFycmF5IGlmIHRoZSBwcm92aWRlZCBieXRlcyBvbmx5IGNvbnRhaW5lZCBhXG4gICAgICogYmluYXJ5IENJRCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlRmlyc3QoYnl0ZXMpIHtcbiAgICAgICAgY29uc3Qgc3BlY3MgPSBDSUQuaW5zcGVjdEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgY29uc3QgcHJlZml4U2l6ZSA9IHNwZWNzLnNpemUgLSBzcGVjcy5tdWx0aWhhc2hTaXplO1xuICAgICAgICBjb25zdCBtdWx0aWhhc2hCeXRlcyA9IGNvZXJjZShieXRlcy5zdWJhcnJheShwcmVmaXhTaXplLCBwcmVmaXhTaXplICsgc3BlY3MubXVsdGloYXNoU2l6ZSkpO1xuICAgICAgICBpZiAobXVsdGloYXNoQnl0ZXMuYnl0ZUxlbmd0aCAhPT0gc3BlY3MubXVsdGloYXNoU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlnZXN0Qnl0ZXMgPSBtdWx0aWhhc2hCeXRlcy5zdWJhcnJheShzcGVjcy5tdWx0aWhhc2hTaXplIC0gc3BlY3MuZGlnZXN0U2l6ZSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBEaWdlc3QuRGlnZXN0KHNwZWNzLm11bHRpaGFzaENvZGUsIHNwZWNzLmRpZ2VzdFNpemUsIGRpZ2VzdEJ5dGVzLCBtdWx0aWhhc2hCeXRlcyk7XG4gICAgICAgIGNvbnN0IGNpZCA9IHNwZWNzLnZlcnNpb24gPT09IDBcbiAgICAgICAgICAgID8gQ0lELmNyZWF0ZVYwKGRpZ2VzdClcbiAgICAgICAgICAgIDogQ0lELmNyZWF0ZVYxKHNwZWNzLmNvZGVjLCBkaWdlc3QpO1xuICAgICAgICByZXR1cm4gW2NpZCwgYnl0ZXMuc3ViYXJyYXkoc3BlY3Muc2l6ZSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNwZWN0IHRoZSBpbml0aWFsIGJ5dGVzIG9mIGEgQ0lEIHRvIGRldGVybWluZSBpdHMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEludm9sdmVzIGRlY29kaW5nIHVwIHRvIDQgdmFyaW50cy4gVHlwaWNhbGx5IHRoaXMgd2lsbCByZXF1aXJlIG9ubHkgNCB0byA2XG4gICAgICogYnl0ZXMgYnV0IGZvciBsYXJnZXIgbXVsdGljb2RlYyBjb2RlIHZhbHVlcyBhbmQgbGFyZ2VyIG11bHRpaGFzaCBkaWdlc3RcbiAgICAgKiBsZW5ndGhzIHRoZXNlIHZhcmludHMgY2FuIGJlIHF1aXRlIGxhcmdlLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGF0IGxlYXN0XG4gICAgICogMTAgYnl0ZXMgYmUgbWFkZSBhdmFpbGFibGUgaW4gdGhlIGBpbml0aWFsQnl0ZXNgIGFyZ3VtZW50IGZvciBhIGNvbXBsZXRlXG4gICAgICogaW5zcGVjdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zcGVjdEJ5dGVzKGluaXRpYWxCeXRlcykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB2ZXJzaW9uID0gbmV4dCgpO1xuICAgICAgICBsZXQgY29kZWMgPSBEQUdfUEJfQ09ERTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDE4KSB7XG4gICAgICAgICAgICAvLyBDSUR2MFxuICAgICAgICAgICAgdmVyc2lvbiA9IDA7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZWMgPSBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb24gIT09IDAgJiYgdmVyc2lvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgQ0lEIHZlcnNpb24gJHt2ZXJzaW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeFNpemUgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IG11bHRpaGFzaENvZGUgPSBuZXh0KCk7IC8vIG11bHRpaGFzaCBjb2RlXG4gICAgICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCk7IC8vIG11bHRpaGFzaCBsZW5ndGhcbiAgICAgICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemU7XG4gICAgICAgIGNvbnN0IG11bHRpaGFzaFNpemUgPSBzaXplIC0gcHJlZml4U2l6ZTtcbiAgICAgICAgcmV0dXJuIHsgdmVyc2lvbiwgY29kZWMsIG11bHRpaGFzaENvZGUsIGRpZ2VzdFNpemUsIG11bHRpaGFzaFNpemUsIHNpemUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgY2lkIGluIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFuZCBjcmVhdGVzIGFuIGluc3RhbmNlLiBJZiBgYmFzZWBcbiAgICAgKiBkZWNvZGVyIGlzIG5vdCBwcm92aWRlZCB3aWxsIHVzZSBhIGRlZmF1bHQgZnJvbSB0aGUgY29uZmlndXJhdGlvbi4gSXQgd2lsbFxuICAgICAqIHRocm93IGFuIGVycm9yIGlmIGVuY29kaW5nIG9mIHRoZSBDSUQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBzdXBwbGllZCAob3JcbiAgICAgKiBhIGRlZmF1bHQgZGVjb2RlcikuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHNvdXJjZSwgYmFzZSkge1xuICAgICAgICBjb25zdCBbcHJlZml4LCBieXRlc10gPSBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKTtcbiAgICAgICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcyk7XG4gICAgICAgIGlmIChjaWQudmVyc2lvbiA9PT0gMCAmJiBzb3VyY2VbMF0gIT09ICdRJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1ZlcnNpb24gMCBDSUQgc3RyaW5nIG11c3Qgbm90IGluY2x1ZGUgbXVsdGliYXNlIHByZWZpeCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhY2hlIHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBhdm9pZCBjb21wdXRpbmcgaXQgb24gYHRoaXMudG9TdHJpbmcoKWBcbiAgICAgICAgYmFzZUNhY2hlKGNpZCkuc2V0KHByZWZpeCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGNpZDtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKSB7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLy8gQ0lEdjAgaXMgcGFyc2VkIGRpZmZlcmVudGx5XG4gICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSA/PyBiYXNlNThidGM7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJhc2U1OGJ0Yy5wcmVmaXgsXG4gICAgICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGUoYCR7YmFzZTU4YnRjLnByZWZpeH0ke3NvdXJjZX1gKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGJhc2U1OGJ0Yy5wcmVmaXg6IHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlID8/IGJhc2U1OGJ0YztcbiAgICAgICAgICAgIHJldHVybiBbYmFzZTU4YnRjLnByZWZpeCwgZGVjb2Rlci5kZWNvZGUoc291cmNlKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBiYXNlMzIucHJlZml4OiB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSA/PyBiYXNlMzI7XG4gICAgICAgICAgICByZXR1cm4gW2Jhc2UzMi5wcmVmaXgsIGRlY29kZXIuZGVjb2RlKHNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYmFzZTM2LnByZWZpeDoge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgPz8gYmFzZTM2O1xuICAgICAgICAgICAgcmV0dXJuIFtiYXNlMzYucHJlZml4LCBkZWNvZGVyLmRlY29kZShzb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhcnNlIG5vbiBiYXNlMzIsIGJhc2UzNiBvciBiYXNlNThidGMgZW5jb2RlZCBDSUQgbXVsdGliYXNlIGRlY29kZXIgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtzb3VyY2VbMF0sIGJhc2UuZGVjb2RlKHNvdXJjZSldO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmdWMChieXRlcywgY2FjaGUsIGJhc2UpIHtcbiAgICBjb25zdCB7IHByZWZpeCB9ID0gYmFzZTtcbiAgICBpZiAocHJlZml4ICE9PSBiYXNlNThidGMucHJlZml4KSB7XG4gICAgICAgIHRocm93IEVycm9yKGBDYW5ub3Qgc3RyaW5nIGVuY29kZSBWMCBpbiAke2Jhc2UubmFtZX0gZW5jb2RpbmdgKTtcbiAgICB9XG4gICAgY29uc3QgY2lkID0gY2FjaGUuZ2V0KHByZWZpeCk7XG4gICAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNpZCA9IGJhc2UuZW5jb2RlKGJ5dGVzKS5zbGljZSgxKTtcbiAgICAgICAgY2FjaGUuc2V0KHByZWZpeCwgY2lkKTtcbiAgICAgICAgcmV0dXJuIGNpZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjaWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmdWMShieXRlcywgY2FjaGUsIGJhc2UpIHtcbiAgICBjb25zdCB7IHByZWZpeCB9ID0gYmFzZTtcbiAgICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgICBpZiAoY2lkID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpO1xuICAgICAgICBjYWNoZS5zZXQocHJlZml4LCBjaWQpO1xuICAgICAgICByZXR1cm4gY2lkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNpZDtcbiAgICB9XG59XG5jb25zdCBEQUdfUEJfQ09ERSA9IDB4NzA7XG5jb25zdCBTSEFfMjU2X0NPREUgPSAweDEyO1xuZnVuY3Rpb24gZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCkge1xuICAgIGNvbnN0IGNvZGVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmVyc2lvbik7XG4gICAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoT2Zmc2V0ICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpO1xuICAgIHZhcmludC5lbmNvZGVUbyh2ZXJzaW9uLCBieXRlcywgMCk7XG4gICAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KTtcbiAgICBieXRlcy5zZXQobXVsdGloYXNoLCBoYXNoT2Zmc2V0KTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/cid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/codecs/interface.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/codecs/interface.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2NvZGVjcy9pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZGlzdC9zcmMvY29kZWNzL2ludGVyZmFjZS5qcz84Y2NhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/codecs/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Digest: () => (/* binding */ Digest),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   hasCode: () => (/* binding */ hasCode)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js\");\n\n\n/**\n * Creates a multihash digest.\n */\nfunction create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);\n    const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);\n    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nfunction decode(multihash) {\n    const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);\n    const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);\n    const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nclass Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n/**\n * Used to check that the passed multihash has the passed code\n */\nfunction hasCode(digest, code) {\n    return digest.code === code;\n}\n//# sourceMappingURL=digest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2hhc2hlcy9kaWdlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEyRDtBQUNwQjtBQUN2QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsdUJBQXVCLHNEQUFxQjtBQUM1QyxzQ0FBc0Msc0RBQXFCO0FBQzNEO0FBQ0EsSUFBSSxnREFBZTtBQUNuQixJQUFJLGdEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLGlEQUFNO0FBQ3hCLCtCQUErQiw4Q0FBYTtBQUM1QyxpQ0FBaUMsOENBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9oYXNoZXMvZGlnZXN0LmpzPzkwZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29lcmNlLCBlcXVhbHMgYXMgZXF1YWxCeXRlcyB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuLi92YXJpbnQuanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbXVsdGloYXNoIGRpZ2VzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjb2RlLCBkaWdlc3QpIHtcbiAgICBjb25zdCBzaXplID0gZGlnZXN0LmJ5dGVMZW5ndGg7XG4gICAgY29uc3Qgc2l6ZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aChjb2RlKTtcbiAgICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0T2Zmc2V0ICsgc2l6ZSk7XG4gICAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCAwKTtcbiAgICB2YXJpbnQuZW5jb2RlVG8oc2l6ZSwgYnl0ZXMsIHNpemVPZmZzZXQpO1xuICAgIGJ5dGVzLnNldChkaWdlc3QsIGRpZ2VzdE9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBEaWdlc3QoY29kZSwgc2l6ZSwgZGlnZXN0LCBieXRlcyk7XG59XG4vKipcbiAqIFR1cm5zIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIG11bHRpaGFzaCBkaWdlc3QgaW50byBhbiBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShtdWx0aWhhc2gpIHtcbiAgICBjb25zdCBieXRlcyA9IGNvZXJjZShtdWx0aWhhc2gpO1xuICAgIGNvbnN0IFtjb2RlLCBzaXplT2Zmc2V0XSA9IHZhcmludC5kZWNvZGUoYnl0ZXMpO1xuICAgIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0KSk7XG4gICAgY29uc3QgZGlnZXN0ID0gYnl0ZXMuc3ViYXJyYXkoc2l6ZU9mZnNldCArIGRpZ2VzdE9mZnNldCk7XG4gICAgaWYgKGRpZ2VzdC5ieXRlTGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGI7XG4gICAgICAgIHJldHVybiAoYS5jb2RlID09PSBkYXRhLmNvZGUgJiZcbiAgICAgICAgICAgIGEuc2l6ZSA9PT0gZGF0YS5zaXplICYmXG4gICAgICAgICAgICBkYXRhLmJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgICAgICAgICAgZXF1YWxCeXRlcyhhLmJ5dGVzLCBkYXRhLmJ5dGVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbXVsdGloYXNoIGRpZ2VzdCB3aGljaCBjYXJyaWVzIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaGFzaGluZyBhbGdvcml0aG0gYW5kIGFuIGFjdHVhbCBoYXNoIGRpZ2VzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIERpZ2VzdCB7XG4gICAgY29kZTtcbiAgICBzaXplO1xuICAgIGRpZ2VzdDtcbiAgICBieXRlcztcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbXVsdGloYXNoIGRpZ2VzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VkIHRvIGNoZWNrIHRoYXQgdGhlIHBhc3NlZCBtdWx0aWhhc2ggaGFzIHRoZSBwYXNzZWQgY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29kZShkaWdlc3QsIGNvZGUpIHtcbiAgICByZXR1cm4gZGlnZXN0LmNvZGUgPT09IGNvZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWdlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/hasher.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/hasher.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hasher: () => (/* binding */ Hasher),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js\");\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20;\nfunction from({ name, code, encode, minDigestLength, maxDigestLength }) {\n    return new Hasher(name, code, encode, minDigestLength, maxDigestLength);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nclass Hasher {\n    name;\n    code;\n    encode;\n    minDigestLength;\n    maxDigestLength;\n    constructor(name, code, encode, minDigestLength, maxDigestLength) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n        this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;\n        this.maxDigestLength = maxDigestLength;\n    }\n    digest(input, options) {\n        if (options?.truncate != null) {\n            if (options.truncate < this.minDigestLength) {\n                throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);\n            }\n            if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n                throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);\n            }\n        }\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            if (result instanceof Uint8Array) {\n                return createDigest(result, this.code, options?.truncate);\n            }\n            return result.then(digest => createDigest(digest, this.code, options?.truncate));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest(digest, code, truncate) {\n    if (truncate != null && truncate !== digest.byteLength) {\n        if (truncate > digest.byteLength) {\n            throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`);\n        }\n        digest = digest.subarray(0, truncate);\n    }\n    return _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(code, digest);\n}\n//# sourceMappingURL=hasher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2hhc2hlcy9oYXNoZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBQ3RDO0FBQ08sZ0JBQWdCLHNEQUFzRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixxQkFBcUI7QUFDbEg7QUFDQTtBQUNBLDBGQUEwRixxQkFBcUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysa0JBQWtCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9oYXNoZXMvaGFzaGVyLmpzPzA4ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vZGlnZXN0LmpzJztcbmNvbnN0IERFRkFVTFRfTUlOX0RJR0VTVF9MRU5HVEggPSAyMDtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHsgbmFtZSwgY29kZSwgZW5jb2RlLCBtaW5EaWdlc3RMZW5ndGgsIG1heERpZ2VzdExlbmd0aCB9KSB7XG4gICAgcmV0dXJuIG5ldyBIYXNoZXIobmFtZSwgY29kZSwgZW5jb2RlLCBtaW5EaWdlc3RMZW5ndGgsIG1heERpZ2VzdExlbmd0aCk7XG59XG4vKipcbiAqIEhhc2hlciByZXByZXNlbnRzIGEgaGFzaGluZyBhbGdvcml0aG0gaW1wbGVtZW50YXRpb24gdGhhdCBwcm9kdWNlcyBhc1xuICogYE11bHRpaGFzaERpZ2VzdGAuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoZXIge1xuICAgIG5hbWU7XG4gICAgY29kZTtcbiAgICBlbmNvZGU7XG4gICAgbWluRGlnZXN0TGVuZ3RoO1xuICAgIG1heERpZ2VzdExlbmd0aDtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb2RlLCBlbmNvZGUsIG1pbkRpZ2VzdExlbmd0aCwgbWF4RGlnZXN0TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gZW5jb2RlO1xuICAgICAgICB0aGlzLm1pbkRpZ2VzdExlbmd0aCA9IG1pbkRpZ2VzdExlbmd0aCA/PyBERUZBVUxUX01JTl9ESUdFU1RfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heERpZ2VzdExlbmd0aCA9IG1heERpZ2VzdExlbmd0aDtcbiAgICB9XG4gICAgZGlnZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zPy50cnVuY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50cnVuY2F0ZSA8IHRoaXMubWluRGlnZXN0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRydW5jYXRlIG9wdGlvbiwgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHt0aGlzLm1pbkRpZ2VzdExlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1heERpZ2VzdExlbmd0aCAhPSBudWxsICYmIG9wdGlvbnMudHJ1bmNhdGUgPiB0aGlzLm1heERpZ2VzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cnVuY2F0ZSBvcHRpb24sIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7dGhpcy5tYXhEaWdlc3RMZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRGlnZXN0KHJlc3VsdCwgdGhpcy5jb2RlLCBvcHRpb25zPy50cnVuY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZGlnZXN0ID0+IGNyZWF0ZURpZ2VzdChkaWdlc3QsIHRoaXMuY29kZSwgb3B0aW9ucz8udHJ1bmNhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgRGlnZXN0IGZyb20gdGhlIHBhc3NlZCB1aW50OGFycmF5IGFuZCBjb2RlLCBvcHRpb25hbGx5IHRydW5jYXRpbmcgaXRcbiAqIGZpcnN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEaWdlc3QoZGlnZXN0LCBjb2RlLCB0cnVuY2F0ZSkge1xuICAgIGlmICh0cnVuY2F0ZSAhPSBudWxsICYmIHRydW5jYXRlICE9PSBkaWdlc3QuYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAodHJ1bmNhdGUgPiBkaWdlc3QuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRydW5jYXRlIG9wdGlvbiwgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHtkaWdlc3QuYnl0ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBkaWdlc3QgPSBkaWdlc3Quc3ViYXJyYXkoMCwgdHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gRGlnZXN0LmNyZWF0ZShjb2RlLCBkaWdlc3QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/hasher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/interface.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/interface.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// # Multihash\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2hhc2hlcy9pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ1U7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9oYXNoZXMvaW50ZXJmYWNlLmpzPzE5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gIyBNdWx0aWhhc2hcbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID: () => (/* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_1__.CID),\n/* harmony export */   bytes: () => (/* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   digest: () => (/* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   hasher: () => (/* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   varint: () => (/* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cid.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/cid.js\");\n/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashes/digest.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/digest.js\");\n/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/hasher.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./varint.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js\");\n/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/interface.js\");\n/**\n * @packageDocumentation\n *\n * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.\n *\n * This library provides implementations for most basics and many others can be found in linked repositories.\n *\n * ```TypeScript\n * import { CID } from 'multiformats/cid'\n * import * as json from 'multiformats/codecs/json'\n * import { sha256 } from 'multiformats/hashes/sha2'\n *\n * const bytes = json.encode({ hello: 'world' })\n *\n * const hash = await sha256.digest(bytes)\n * const cid = CID.create(1, json.code, hash)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Creating Blocks\n *\n * ```TypeScript\n * import * as Block from 'multiformats/block'\n * import * as codec from '@ipld/dag-cbor'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * const value = { hello: 'world' }\n *\n * // encode a block\n * let block = await Block.encode({ value, codec, hasher })\n *\n * block.value // { hello: 'world' }\n * block.bytes // Uint8Array\n * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec\n *\n * // you can also decode blocks from their binary state\n * block = await Block.decode({ bytes: block.bytes, codec, hasher })\n *\n * // if you have the cid you can also verify the hash on decode\n * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })\n * ```\n *\n * ## Multibase Encoders / Decoders / Codecs\n *\n * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:\n *\n * ```TypeScript\n * import { base64 } from \"multiformats/bases/base64\"\n * cid.toString(base64.encoder)\n * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'\n * ```\n *\n * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:\n *\n * ```TypeScript\n * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * Dual of multibase encoder & decoder is defined as multibase codec and it exposes\n * them as `encoder` and `decoder` properties. For added convenience codecs also\n * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be\n * used as either or both:\n *\n * ```TypeScript\n * cid.toString(base64)\n * CID.parse(cid.toString(base64), base64)\n * ```\n *\n * **Note:** CID implementation comes bundled with `base32` and `base58btc`\n * multibase codecs so that CIDs can be base serialized to (version specific)\n * default base encoding and parsed without having to supply base encoders/decoders:\n *\n * ```TypeScript\n * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')\n * v1.toString()\n * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'\n *\n * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')\n * v0.toString()\n * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\n * v0.toV1().toString()\n * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'\n * ```\n *\n * ## Multicodec Encoders / Decoders / Codecs\n *\n * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).\n * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.\n * Here is an example implementation of JSON `BlockCodec`.\n *\n * ```TypeScript\n * export const { name, code, encode, decode } = {\n *   name: 'json',\n *   code: 0x0200,\n *   encode: json => new TextEncoder().encode(JSON.stringify(json)),\n *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))\n * }\n * ```\n *\n * ## Multihash Hashers\n *\n * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:\n *\n * ```TypeScript\n * import * as hasher from 'multiformats/hashes/hasher'\n *\n * const sha256 = hasher.from({\n *   // As per multiformats table\n *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9\n *   name: 'sha2-256',\n *   code: 0x12,\n *\n *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())\n * })\n *\n * const hash = await sha256.digest(json.encode({ hello: 'world' }))\n * CID.create(1, json.code, hash)\n *\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Traversal\n *\n * This library contains higher-order functions for traversing graphs of data easily.\n *\n * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.\n *\n * ```TypeScript\n * import { walk } from 'multiformats/traversal'\n * import * as Block from 'multiformats/block'\n * import * as codec from 'multiformats/codecs/json'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * // build a DAG (a single block for this simple example)\n * const value = { hello: 'world' }\n * const block = await Block.encode({ value, codec, hasher })\n * const { cid } = block\n * console.log(cid)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n *\n * // create a loader function that also collects CIDs of blocks in\n * // their traversal order\n * const load = (cid, blocks) => async (cid) => {\n *   // fetch a block using its cid\n *   // e.g.: const block = await fetchBlockByCID(cid)\n *   blocks.push(cid)\n *   return block\n * }\n *\n * // collect blocks in this DAG starting from the root `cid`\n * const blocks = []\n * await walk({ cid, load: load(cid, blocks) })\n *\n * console.log(blocks)\n * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]\n * ```\n *\n * ## Legacy interface\n *\n * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an\n * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.\n *\n * ## Implementations\n *\n * By default, no base encodings (other than base32 & base58btc), hash functions,\n * or codec implementations are exposed by `multiformats`, you need to\n * import the ones you need yourself.\n *\n * ### Multibase codecs\n *\n * | bases                                                         | import                      | repo                                                                                              |\n * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |\n * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n *\n * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.\n *\n * ### Multihash hashers\n *\n * | hashes                                                                                                                          | import                         | repo                                                                                                               |\n * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\n * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |\n * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |\n * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |\n * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |\n * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |\n *\n * ### IPLD codecs (multicodec)\n *\n * | codec      | import                     | repo                                                                                                   |\n * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |\n * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |\n * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |\n * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |\n * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |\n */\n\n\n\n\n\n// This way TS will also expose all the types from module\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0EsZ0NBQWdDLG1EQUFtRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQ0FBc0Msc0JBQXNCO0FBQzVELFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDTDtBQUNjO0FBQ0E7QUFDUDtBQUN0QztBQUMrQjtBQUNlO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2luZGV4LmpzPzMyOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqXG4gKiBUaGlzIGxpYnJhcnkgZGVmaW5lcyBjb21tb24gaW50ZXJmYWNlcyBhbmQgbG93IGxldmVsIGJ1aWxkaW5nIGJsb2NrcyBmb3IgdmFyaW91cyBpbnRlcnJlbGF0ZWQgbXVsdGlmb3JtYXQgdGVjaG5vbG9naWVzIChtdWx0aWNvZGVjLCBtdWx0aWhhc2gsIG11bHRpYmFzZSwgYW5kIENJRCkuIFRoZXkgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGN1c3RvbSBiYXNlIGVuY29kZXJzIC8gZGVjb2RlcnMgLyBjb2RlY3MsIGNvZGVjIGVuY29kZXJzIC9kZWNvZGVycyBhbmQgbXVsdGloYXNoIGhhc2hlcnMgdGhhdCBjb21wbHkgdG8gdGhlIGludGVyZmFjZSB0aGF0IGxheWVycyBhYm92ZSBhc3N1bWUuXG4gKlxuICogVGhpcyBsaWJyYXJ5IHByb3ZpZGVzIGltcGxlbWVudGF0aW9ucyBmb3IgbW9zdCBiYXNpY3MgYW5kIG1hbnkgb3RoZXJzIGNhbiBiZSBmb3VuZCBpbiBsaW5rZWQgcmVwb3NpdG9yaWVzLlxuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG4gKiBpbXBvcnQgKiBhcyBqc29uIGZyb20gJ211bHRpZm9ybWF0cy9jb2RlY3MvanNvbidcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbiAqXG4gKiBjb25zdCBieXRlcyA9IGpzb24uZW5jb2RlKHsgaGVsbG86ICd3b3JsZCcgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgc2hhMjU2LmRpZ2VzdChieXRlcylcbiAqIGNvbnN0IGNpZCA9IENJRC5jcmVhdGUoMSwganNvbi5jb2RlLCBoYXNoKVxuICogLy8+IENJRChiYWdhYWllcmFzb3JkczRuamN0czZ2czdxdmRqZmN2Z251bWU0aHFvaGY2NXpzZmd1cHJxcGhzM2ljd2VhKVxuICogYGBgXG4gKlxuICogIyMgQ3JlYXRpbmcgQmxvY2tzXG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0ICogYXMgQmxvY2sgZnJvbSAnbXVsdGlmb3JtYXRzL2Jsb2NrJ1xuICogaW1wb3J0ICogYXMgY29kZWMgZnJvbSAnQGlwbGQvZGFnLWNib3InXG4gKiBpbXBvcnQgeyBzaGEyNTYgYXMgaGFzaGVyIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJ1xuICpcbiAqIGNvbnN0IHZhbHVlID0geyBoZWxsbzogJ3dvcmxkJyB9XG4gKlxuICogLy8gZW5jb2RlIGEgYmxvY2tcbiAqIGxldCBibG9jayA9IGF3YWl0IEJsb2NrLmVuY29kZSh7IHZhbHVlLCBjb2RlYywgaGFzaGVyIH0pXG4gKlxuICogYmxvY2sudmFsdWUgLy8geyBoZWxsbzogJ3dvcmxkJyB9XG4gKiBibG9jay5ieXRlcyAvLyBVaW50OEFycmF5XG4gKiBibG9jay5jaWQgICAvLyBDSUQoKSB3LyBzaGEyLTI1NiBoYXNoIGFkZHJlc3MgYW5kIGRhZy1jYm9yIGNvZGVjXG4gKlxuICogLy8geW91IGNhbiBhbHNvIGRlY29kZSBibG9ja3MgZnJvbSB0aGVpciBiaW5hcnkgc3RhdGVcbiAqIGJsb2NrID0gYXdhaXQgQmxvY2suZGVjb2RlKHsgYnl0ZXM6IGJsb2NrLmJ5dGVzLCBjb2RlYywgaGFzaGVyIH0pXG4gKlxuICogLy8gaWYgeW91IGhhdmUgdGhlIGNpZCB5b3UgY2FuIGFsc28gdmVyaWZ5IHRoZSBoYXNoIG9uIGRlY29kZVxuICogYmxvY2sgPSBhd2FpdCBCbG9jay5jcmVhdGUoeyBieXRlczogYmxvY2suYnl0ZXMsIGNpZDogYmxvY2suY2lkLCBjb2RlYywgaGFzaGVyIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyBNdWx0aWJhc2UgRW5jb2RlcnMgLyBEZWNvZGVycyAvIENvZGVjc1xuICpcbiAqIENJRHMgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIG11bHRpYmFzZSBlbmNvZGVycyB0aGF0IGltcGxlbWVudCBbYE11bHRpYmFzZUVuY29kZXJgXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0cy9ibG9iL21hc3Rlci9zcmMvYmFzZXMvaW50ZXJmYWNlLnRzKSBpbnRlcmZhY2UuIFRoaXMgbGlicmFyeSBwcm92aWRlcyBxdWl0ZSBhIGZldyBpbXBsZW1lbnRhdGlvbnMgdGhhdCBjYW4gYmUgaW1wb3J0ZWQ6XG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIm11bHRpZm9ybWF0cy9iYXNlcy9iYXNlNjRcIlxuICogY2lkLnRvU3RyaW5nKGJhc2U2NC5lbmNvZGVyKVxuICogLy8+ICdtQVlBRUVpQ1Rvamx4cVJUbDZzdndxTkpSVk0yakNjUEJ4eSs3bVJUVWZHRHp5MmdWaUEnXG4gKiBgYGBcbiAqXG4gKiBQYXJzaW5nIENJRCBzdHJpbmcgc2VyaWFsaXplZCBDSURzIHJlcXVpcmVzIG11bHRpYmFzZSBkZWNvZGVyIHRoYXQgaW1wbGVtZW50cyBbYE11bHRpYmFzZURlY29kZXJgXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0cy9ibG9iL21hc3Rlci9zcmMvYmFzZXMvaW50ZXJmYWNlLnRzKSBpbnRlcmZhY2UuIFRoaXMgbGlicmFyeSBwcm92aWRlcyBhIGRlY29kZXIgZm9yIGV2ZXJ5IGVuY29kZXIgaXQgcHJvdmlkZXM6XG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogQ0lELnBhcnNlKCdtQVlBRUVpQ1Rvamx4cVJUbDZzdndxTkpSVk0yakNjUEJ4eSs3bVJUVWZHRHp5MmdWaUEnLCBiYXNlNjQuZGVjb2RlcilcbiAqIC8vPiBDSUQoYmFnYWFpZXJhc29yZHM0bmpjdHM2dnM3cXZkamZjdmdudW1lNGhxb2hmNjV6c2ZndXBycXBoczNpY3dlYSlcbiAqIGBgYFxuICpcbiAqIER1YWwgb2YgbXVsdGliYXNlIGVuY29kZXIgJiBkZWNvZGVyIGlzIGRlZmluZWQgYXMgbXVsdGliYXNlIGNvZGVjIGFuZCBpdCBleHBvc2VzXG4gKiB0aGVtIGFzIGBlbmNvZGVyYCBhbmQgYGRlY29kZXJgIHByb3BlcnRpZXMuIEZvciBhZGRlZCBjb252ZW5pZW5jZSBjb2RlY3MgYWxzb1xuICogaW1wbGVtZW50IGBNdWx0aWJhc2VFbmNvZGVyYCBhbmQgYE11bHRpYmFzZURlY29kZXJgIGludGVyZmFjZXMgc28gdGhleSBjb3VsZCBiZVxuICogdXNlZCBhcyBlaXRoZXIgb3IgYm90aDpcbiAqXG4gKiBgYGBUeXBlU2NyaXB0XG4gKiBjaWQudG9TdHJpbmcoYmFzZTY0KVxuICogQ0lELnBhcnNlKGNpZC50b1N0cmluZyhiYXNlNjQpLCBiYXNlNjQpXG4gKiBgYGBcbiAqXG4gKiAqKk5vdGU6KiogQ0lEIGltcGxlbWVudGF0aW9uIGNvbWVzIGJ1bmRsZWQgd2l0aCBgYmFzZTMyYCBhbmQgYGJhc2U1OGJ0Y2BcbiAqIG11bHRpYmFzZSBjb2RlY3Mgc28gdGhhdCBDSURzIGNhbiBiZSBiYXNlIHNlcmlhbGl6ZWQgdG8gKHZlcnNpb24gc3BlY2lmaWMpXG4gKiBkZWZhdWx0IGJhc2UgZW5jb2RpbmcgYW5kIHBhcnNlZCB3aXRob3V0IGhhdmluZyB0byBzdXBwbHkgYmFzZSBlbmNvZGVycy9kZWNvZGVyczpcbiAqXG4gKiBgYGBUeXBlU2NyaXB0XG4gKiBjb25zdCB2MSA9IENJRC5wYXJzZSgnYmFnYWFpZXJhc29yZHM0bmpjdHM2dnM3cXZkamZjdmdudW1lNGhxb2hmNjV6c2ZndXBycXBoczNpY3dlYScpXG4gKiB2MS50b1N0cmluZygpXG4gKiAvLz4gJ2JhZ2FhaWVyYXNvcmRzNG5qY3RzNnZzN3F2ZGpmY3ZnbnVtZTRocW9oZjY1enNmZ3VwcnFwaHMzaWN3ZWEnXG4gKlxuICogY29uc3QgdjAgPSBDSUQucGFyc2UoJ1FtZGZUYkJxQlBRN1ZOeFpFWUVqMTRWbVJ1WkJrcUZiaXdSZW9nSmdTMXpSMW4nKVxuICogdjAudG9TdHJpbmcoKVxuICogLy8+ICdRbWRmVGJCcUJQUTdWTnhaRVlFajE0Vm1SdVpCa3FGYml3UmVvZ0pnUzF6UjFuJ1xuICogdjAudG9WMSgpLnRvU3RyaW5nKClcbiAqIC8vPiAnYmFmeWJlaWhkd2RjZWZnaDRkcWtqdjY3dXpjbXc3b2plZTZ4ZWR6ZGV0b2p1empldnRlbnhxdXZ5a3UnXG4gKiBgYGBcbiAqXG4gKiAjIyBNdWx0aWNvZGVjIEVuY29kZXJzIC8gRGVjb2RlcnMgLyBDb2RlY3NcbiAqXG4gKiBUaGlzIGxpYnJhcnkgZGVmaW5lcyBbYEJsb2NrRW5jb2RlcmAsIGBCbG9ja0RlY29kZXJgIGFuZCBgQmxvY2tDb2RlY2AgaW50ZXJmYWNlc10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvYmxvYi9tYXN0ZXIvc3JjL2NvZGVjcy9pbnRlcmZhY2UudHMpLlxuICogQ29kZWMgaW1wbGVtZW50YXRpb25zIHNob3VsZCBjb25mb3JtIHRvIHRoZSBgQmxvY2tDb2RlY2AgaW50ZXJmYWNlIHdoaWNoIGltcGxlbWVudHMgYm90aCBgQmxvY2tFbmNvZGVyYCBhbmQgYEJsb2NrRGVjb2RlcmAuXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgaW1wbGVtZW50YXRpb24gb2YgSlNPTiBgQmxvY2tDb2RlY2AuXG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogZXhwb3J0IGNvbnN0IHsgbmFtZSwgY29kZSwgZW5jb2RlLCBkZWNvZGUgfSA9IHtcbiAqICAgbmFtZTogJ2pzb24nLFxuICogICBjb2RlOiAweDAyMDAsXG4gKiAgIGVuY29kZToganNvbiA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoanNvbikpLFxuICogICBkZWNvZGU6IGJ5dGVzID0+IEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIE11bHRpaGFzaCBIYXNoZXJzXG4gKlxuICogVGhpcyBsaWJyYXJ5IGRlZmluZXMgW2BNdWx0aWhhc2hIYXNoZXJgIGFuZCBgTXVsdGloYXNoRGlnZXN0YCBpbnRlcmZhY2VzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0cy9ibG9iL21hc3Rlci9zcmMvaGFzaGVzL2ludGVyZmFjZS50cykgYW5kIGNvbnZpbmllbnQgZnVuY3Rpb24gZm9yIGltcGxlbWVudGluZyB0aGVtOlxuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCAqIGFzIGhhc2hlciBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2hhc2hlcidcbiAqXG4gKiBjb25zdCBzaGEyNTYgPSBoYXNoZXIuZnJvbSh7XG4gKiAgIC8vIEFzIHBlciBtdWx0aWZvcm1hdHMgdGFibGVcbiAqICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWNvZGVjL2Jsb2IvbWFzdGVyL3RhYmxlLmNzdiNMOVxuICogICBuYW1lOiAnc2hhMi0yNTYnLFxuICogICBjb2RlOiAweDEyLFxuICpcbiAqICAgZW5jb2RlOiAoaW5wdXQpID0+IG5ldyBVaW50OEFycmF5KGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgc2hhMjU2LmRpZ2VzdChqc29uLmVuY29kZSh7IGhlbGxvOiAnd29ybGQnIH0pKVxuICogQ0lELmNyZWF0ZSgxLCBqc29uLmNvZGUsIGhhc2gpXG4gKlxuICogLy8+IENJRChiYWdhYWllcmFzb3JkczRuamN0czZ2czdxdmRqZmN2Z251bWU0aHFvaGY2NXpzZmd1cHJxcGhzM2ljd2VhKVxuICogYGBgXG4gKlxuICogIyMgVHJhdmVyc2FsXG4gKlxuICogVGhpcyBsaWJyYXJ5IGNvbnRhaW5zIGhpZ2hlci1vcmRlciBmdW5jdGlvbnMgZm9yIHRyYXZlcnNpbmcgZ3JhcGhzIG9mIGRhdGEgZWFzaWx5LlxuICpcbiAqIGB3YWxrKClgIHdhbGtzIHRocm91Z2ggdGhlIGxpbmtzIGluIGVhY2ggYmxvY2sgb2YgYSBEQUcgY2FsbGluZyBhIHVzZXItc3VwcGxpZWQgbG9hZGVyIGZ1bmN0aW9uIGZvciBlYWNoIG9uZSwgaW4gZGVwdGgtZmlyc3Qgb3JkZXIgd2l0aCBubyBkdXBsaWNhdGUgYmxvY2sgdmlzaXRzLiBUaGUgbG9hZGVyIHNob3VsZCByZXR1cm4gYSBgQmxvY2tgIG9iamVjdCBhbmQgY2FuIGJlIHVzZWQgdG8gaW5zcGVjdCBhbmQgY29sbGVjdCBibG9jayBvcmRlcmluZyBmb3IgYSBmdWxsIERBRyB3YWxrLiBUaGUgbG9hZGVyIHNob3VsZCBgdGhyb3dgIG9uIGVycm9yLCBhbmQgcmV0dXJuIGBudWxsYCBpZiBhIGJsb2NrIHNob3VsZCBiZSBza2lwcGVkIGJ5IGB3YWxrKClgLlxuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IHdhbGsgfSBmcm9tICdtdWx0aWZvcm1hdHMvdHJhdmVyc2FsJ1xuICogaW1wb3J0ICogYXMgQmxvY2sgZnJvbSAnbXVsdGlmb3JtYXRzL2Jsb2NrJ1xuICogaW1wb3J0ICogYXMgY29kZWMgZnJvbSAnbXVsdGlmb3JtYXRzL2NvZGVjcy9qc29uJ1xuICogaW1wb3J0IHsgc2hhMjU2IGFzIGhhc2hlciB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbiAqXG4gKiAvLyBidWlsZCBhIERBRyAoYSBzaW5nbGUgYmxvY2sgZm9yIHRoaXMgc2ltcGxlIGV4YW1wbGUpXG4gKiBjb25zdCB2YWx1ZSA9IHsgaGVsbG86ICd3b3JsZCcgfVxuICogY29uc3QgYmxvY2sgPSBhd2FpdCBCbG9jay5lbmNvZGUoeyB2YWx1ZSwgY29kZWMsIGhhc2hlciB9KVxuICogY29uc3QgeyBjaWQgfSA9IGJsb2NrXG4gKiBjb25zb2xlLmxvZyhjaWQpXG4gKiAvLz4gQ0lEKGJhZ2FhaWVyYXNvcmRzNG5qY3RzNnZzN3F2ZGpmY3ZnbnVtZTRocW9oZjY1enNmZ3VwcnFwaHMzaWN3ZWEpXG4gKlxuICogLy8gY3JlYXRlIGEgbG9hZGVyIGZ1bmN0aW9uIHRoYXQgYWxzbyBjb2xsZWN0cyBDSURzIG9mIGJsb2NrcyBpblxuICogLy8gdGhlaXIgdHJhdmVyc2FsIG9yZGVyXG4gKiBjb25zdCBsb2FkID0gKGNpZCwgYmxvY2tzKSA9PiBhc3luYyAoY2lkKSA9PiB7XG4gKiAgIC8vIGZldGNoIGEgYmxvY2sgdXNpbmcgaXRzIGNpZFxuICogICAvLyBlLmcuOiBjb25zdCBibG9jayA9IGF3YWl0IGZldGNoQmxvY2tCeUNJRChjaWQpXG4gKiAgIGJsb2Nrcy5wdXNoKGNpZClcbiAqICAgcmV0dXJuIGJsb2NrXG4gKiB9XG4gKlxuICogLy8gY29sbGVjdCBibG9ja3MgaW4gdGhpcyBEQUcgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBgY2lkYFxuICogY29uc3QgYmxvY2tzID0gW11cbiAqIGF3YWl0IHdhbGsoeyBjaWQsIGxvYWQ6IGxvYWQoY2lkLCBibG9ja3MpIH0pXG4gKlxuICogY29uc29sZS5sb2coYmxvY2tzKVxuICogLy8+IFtDSUQoYmFnYWFpZXJhc29yZHM0bmpjdHM2dnM3cXZkamZjdmdudW1lNGhxb2hmNjV6c2ZndXBycXBoczNpY3dlYSldXG4gKiBgYGBcbiAqXG4gKiAjIyBMZWdhY3kgaW50ZXJmYWNlXG4gKlxuICogW2BibG9ja2NvZGVjLXRvLWlwbGQtZm9ybWF0YF0oaHR0cHM6Ly9naXRodWIuY29tL2lwbGQvanMtYmxvY2tjb2RlYy10by1pcGxkLWZvcm1hdCkgY29udmVydHMgYSBtdWx0aWZvcm1hdHMgW2BCbG9ja0NvZGVjYF0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvYmxvYi9tYXN0ZXIvc3JjL2NvZGVjcy9pbnRlcmZhY2UudHMjTDIxKSBpbnRvIGFuXG4gKiBbYGludGVyZmFjZS1pcGxkLWZvcm1hdGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pcGxkL2ludGVyZmFjZS1pcGxkLWZvcm1hdCkgZm9yIHVzZSB3aXRoIHRoZSBbYGlwbGRgXShodHRwczovL2dpdGh1Yi5jb20vaXBsZC9pcGxkKSBwYWNrYWdlLiBUaGlzIGNhbiBoZWxwIGJyaWRnZSBJUExEIGNvZGVjcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgc3RydWN0dXJlIGFuZCBpbnRlcmZhY2VzIGRlZmluZWQgaGVyZSB0byBleGlzdGluZyBjb2RlIHRoYXQgYXNzdW1lcywgb3IgcmVxdWlyZXMgYGludGVyZmFjZS1pcGxkLWZvcm1hdGAuIFRoaXMgYnJpZGdlIGFsc28gaW5jbHVkZXMgdGhlIHJlbGV2YW50IFR5cGVTY3JpcHQgZGVmaW5pdGlvbnMuXG4gKlxuICogIyMgSW1wbGVtZW50YXRpb25zXG4gKlxuICogQnkgZGVmYXVsdCwgbm8gYmFzZSBlbmNvZGluZ3MgKG90aGVyIHRoYW4gYmFzZTMyICYgYmFzZTU4YnRjKSwgaGFzaCBmdW5jdGlvbnMsXG4gKiBvciBjb2RlYyBpbXBsZW1lbnRhdGlvbnMgYXJlIGV4cG9zZWQgYnkgYG11bHRpZm9ybWF0c2AsIHlvdSBuZWVkIHRvXG4gKiBpbXBvcnQgdGhlIG9uZXMgeW91IG5lZWQgeW91cnNlbGYuXG4gKlxuICogIyMjIE11bHRpYmFzZSBjb2RlY3NcbiAqXG4gKiB8IGJhc2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpbXBvcnQgICAgICAgICAgICAgICAgICAgICAgfCByZXBvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgYmFzZTE2YCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYG11bHRpZm9ybWF0cy9iYXNlcy9iYXNlMTZgIHwgW211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvanMtbXVsdGlmb3JtYXRzL3RyZWUvbWFzdGVyL2Jhc2VzKSB8XG4gKiB8IGBiYXNlMzJgLCBgYmFzZTMycGFkYCwgYGJhc2UzMmhleGAsIGBiYXNlMzJoZXhwYWRgLCBgYmFzZTMyemAgfCBgbXVsdGlmb3JtYXRzL2Jhc2VzL2Jhc2UzMmAgfCBbbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0c10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvdHJlZS9tYXN0ZXIvYmFzZXMpIHxcbiAqIHwgYGJhc2U2NGAsIGBiYXNlNjRwYWRgLCBgYmFzZTY0dXJsYCwgYGJhc2U2NHVybHBhZGAgICAgICAgICAgICB8IGBtdWx0aWZvcm1hdHMvYmFzZXMvYmFzZTY0YCB8IFttdWx0aWZvcm1hdHMvanMtbXVsdGlmb3JtYXRzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0cy90cmVlL21hc3Rlci9iYXNlcykgfFxuICogfCBgYmFzZTU4YnRjYCwgYGJhc2U1OGZsaWNrNGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYG11bHRpZm9ybWF0cy9iYXNlcy9iYXNlNThgIHwgW211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvanMtbXVsdGlmb3JtYXRzL3RyZWUvbWFzdGVyL2Jhc2VzKSB8XG4gKlxuICogT3RoZXIgKGxlc3MgdXNlZnVsKSBiYXNlcyBpbXBsZW1lbnRlZCBpbiBbbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0c10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvdHJlZS9tYXN0ZXIvYmFzZXMpIGluY2x1ZGU6IGBiYXNlMmAsIGBiYXNlOGAsIGBiYXNlMTBgLCBgYmFzZTM2YCBhbmQgYGJhc2UyNTZlbW9qaWAuXG4gKlxuICogIyMjIE11bHRpaGFzaCBoYXNoZXJzXG4gKlxuICogfCBoYXNoZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaW1wb3J0ICAgICAgICAgICAgICAgICAgICAgICAgIHwgcmVwbyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBzaGEyLTI1NmAsIGBzaGEyLTUxMmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyYCAgICAgfCBbbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0c10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvdHJlZS9tYXN0ZXIvc3JjL2hhc2hlcykgICAgICAgICAgICAgfFxuICogfCBgc2hhMy0yMjRgLCBgc2hhMy0yNTZgLCBgc2hhMy0zODRgLGBzaGEzLTUxMmAsIGBzaGFrZS0xMjhgLCBgc2hha2UtMjU2YCwgYGtlY2Nhay0yMjRgLCBga2VjY2FrLTI1NmAsIGBrZWNjYWstMzg0YCwgYGtlY2Nhay01MTJgIHwgYEBtdWx0aWZvcm1hdHMvc2hhM2AgICAgICAgICAgIHwgW211bHRpZm9ybWF0cy9qcy1zaGEzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLXNoYTMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYGlkZW50aXR5YCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGBtdWx0aWZvcm1hdHMvaGFzaGVzL2lkZW50aXR5YCB8IFttdWx0aWZvcm1hdHMvanMtbXVsdGlmb3JtYXRzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0cy90cmVlL21hc3Rlci9zcmMvaGFzaGVzL2lkZW50aXR5LmpzKSB8XG4gKiB8IGBtdXJtdXIzLTEyOGAsIGBtdXJtdXIzLTMyYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgQG11bHRpZm9ybWF0cy9tdXJtdXIzYCAgICAgICAgfCBbbXVsdGlmb3JtYXRzL2pzLW11cm11cjNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvanMtbXVybXVyMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYmxha2UyYi0qYCwgYGJsYWtlMnMtKmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYEBtdWx0aWZvcm1hdHMvYmxha2UyYCAgICAgICAgIHwgW211bHRpZm9ybWF0cy9qcy1ibGFrZTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvanMtYmxha2UyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiAjIyMgSVBMRCBjb2RlY3MgKG11bHRpY29kZWMpXG4gKlxuICogfCBjb2RlYyAgICAgIHwgaW1wb3J0ICAgICAgICAgICAgICAgICAgICAgfCByZXBvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgcmF3YCAgICAgIHwgYG11bHRpZm9ybWF0cy9jb2RlY3MvcmF3YCAgfCBbbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0c10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvdHJlZS9tYXN0ZXIvc3JjL2NvZGVjcykgfFxuICogfCBganNvbmAgICAgIHwgYG11bHRpZm9ybWF0cy9jb2RlY3MvanNvbmAgfCBbbXVsdGlmb3JtYXRzL2pzLW11bHRpZm9ybWF0c10oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9qcy1tdWx0aWZvcm1hdHMvdHJlZS9tYXN0ZXIvc3JjL2NvZGVjcykgfFxuICogfCBgZGFnLWNib3JgIHwgYEBpcGxkL2RhZy1jYm9yYCAgICAgICAgICAgfCBbaXBsZC9qcy1kYWctY2Jvcl0oaHR0cHM6Ly9naXRodWIuY29tL2lwbGQvanMtZGFnLWNib3IpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgZGFnLWpzb25gIHwgYEBpcGxkL2RhZy1qc29uYCAgICAgICAgICAgfCBbaXBsZC9qcy1kYWctanNvbl0oaHR0cHM6Ly9naXRodWIuY29tL2lwbGQvanMtZGFnLWpzb24pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgZGFnLXBiYCAgIHwgYEBpcGxkL2RhZy1wYmAgICAgICAgICAgICAgfCBbaXBsZC9qcy1kYWctcGJdKGh0dHBzOi8vZ2l0aHViLmNvbS9pcGxkL2pzLWRhZy1wYikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgZGFnLWpvc2VgIHwgYGRhZy1qb3NlYCAgICAgICAgICAgICAgICAgfCBbY2VyYW1pY25ldHdvcmsvanMtZGFnLWpvc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9jZXJhbWljbmV0d29yay9qcy1kYWctam9zZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICovXG5pbXBvcnQgKiBhcyBieXRlcyBmcm9tICcuL2J5dGVzLmpzJztcbmltcG9ydCB7IENJRCB9IGZyb20gJy4vY2lkLmpzJztcbmltcG9ydCAqIGFzIGRpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnO1xuaW1wb3J0ICogYXMgaGFzaGVyIGZyb20gJy4vaGFzaGVzL2hhc2hlci5qcyc7XG5pbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi92YXJpbnQuanMnO1xuLy8gVGhpcyB3YXkgVFMgd2lsbCBhbHNvIGV4cG9zZSBhbGwgdGhlIHR5cGVzIGZyb20gbW9kdWxlXG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZS5qcyc7XG5leHBvcnQgeyBDSUQsIGhhc2hlciwgZGlnZXN0LCB2YXJpbnQsIGJ5dGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/interface.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/interface.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bases_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/bases/interface.js\");\n/* harmony import */ var _hashes_interface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/hashes/interface.js\");\n/* harmony import */ var _codecs_interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./codecs/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/codecs/interface.js\");\n/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/link/interface.js\");\n/* harmony import */ var _block_interface_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./block/interface.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/block/interface.js\");\n\n\n\n\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFDQztBQUNBO0FBQ0Y7QUFDQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy9pbnRlcmZhY2UuanM/NjJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Jhc2VzL2ludGVyZmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hhc2hlcy9pbnRlcmZhY2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb2RlY3MvaW50ZXJmYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGluay9pbnRlcmZhY2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ibG9jay9pbnRlcmZhY2UuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/link/interface.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/link/interface.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2xpbmsvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL2xpbmsvaW50ZXJmYWNlLmpzPzU4ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/link/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encodeTo: () => (/* binding */ encodeTo),\n/* harmony export */   encodingLength: () => (/* binding */ encodingLength)\n/* harmony export */ });\n/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/varint.js */ \"(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/varint.js\");\n\nfunction decode(data, offset = 0) {\n    const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(data, offset);\n    return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode.bytes];\n}\nfunction encodeTo(int, target, offset = 0) {\n    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encode(int, target, offset);\n    return target;\n}\nfunction encodingLength(int) {\n    return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ2pDO0FBQ1AsaUJBQWlCLHlEQUFNO0FBQ3ZCLGtCQUFrQix5REFBTTtBQUN4QjtBQUNPO0FBQ1AsSUFBSSx5REFBTTtBQUNWO0FBQ0E7QUFDTztBQUNQLFdBQVcseURBQU07QUFDakI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy92YXJpbnQuanM/OGIyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFyaW50IGZyb20gJy4vdmVuZG9yL3ZhcmludC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICAgIHJldHVybiBbY29kZSwgdmFyaW50LmRlY29kZS5ieXRlc107XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVG8oaW50LCB0YXJnZXQsIG9mZnNldCA9IDApIHtcbiAgICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGgoaW50KSB7XG4gICAgcmV0dXJuIHZhcmludC5lbmNvZGluZ0xlbmd0aChpbnQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFyaW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/varint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/base-x.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/base-x.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);\n//# sourceMappingURL=base-x.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL3ZlbmRvci9iYXNlLXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxrREFBa0Q7QUFDbEQ7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2Q0FBNkM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZDQUE2QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSwrQkFBK0IsRUFBQztBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9kaXN0L3NyYy92ZW5kb3IvYmFzZS14LmpzP2M1MzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gQUxQSEFCRVRcbiAqIEBwYXJhbSB7YW55fSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGJhc2UoQUxQSEFCRVQsIG5hbWUpIHtcbiAgICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpO1xuICAgIH1cbiAgICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSk7XG4gICAgICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpO1xuICAgICAgICB9XG4gICAgICAgIEJBU0VfTUFQW3hjXSA9IGk7XG4gICAgfVxuICAgIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICAgIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMCk7XG4gICAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KTsgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTsgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueVtdIHwgSXRlcmFibGU8bnVtYmVyPn0gc291cmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlKHNvdXJjZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHBiZWdpbiA9IDA7XG4gICAgICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgICAgICAgcGJlZ2luKys7XG4gICAgICAgICAgICB6ZXJvZXMrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMDtcbiAgICAgICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICAgICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl07XG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICAgICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDA7XG4gICAgICAgICAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoID0gaTtcbiAgICAgICAgICAgIHBiZWdpbisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICAgICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgICAgICAgIGl0MisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0Mikge1xuICAgICAgICAgICAgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gc291cmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlKHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHN6ID0gMDtcbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHNwYWNlcy5cbiAgICAgICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgICAgICAgIHplcm9lcysrO1xuICAgICAgICAgICAgcHN6Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMDsgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgICAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgICAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDA7XG4gICAgICAgICAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW5ndGggPSBpO1xuICAgICAgICAgICAgcHN6Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCB0cmFpbGluZyBzcGFjZXMuXG4gICAgICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgICAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgICAgICAgIGl0NCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpO1xuICAgICAgICB2YXIgaiA9IHplcm9lcztcbiAgICAgICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKTtcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi0ke25hbWV9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGRlY29kZTogZGVjb2RlXG4gICAgfTtcbn1cbnZhciBzcmMgPSBiYXNlO1xudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5leHBvcnQgZGVmYXVsdCBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS14LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/base-x.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/varint.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/varint.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);\n//# sourceMappingURL=varint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL3ZlbmRvci92YXJpbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsWUFBWSxFQUFDO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Rpc3Qvc3JjL3ZlbmRvci92YXJpbnQuanM/MGZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGVuY29kZV8xID0gZW5jb2RlO1xudmFyIE1TQiA9IDB4ODAsIFJFU1QgPSAweDdGLCBNU0JBTEwgPSB+UkVTVCwgSU5UID0gTWF0aC5wb3coMiwgMzEpO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKiBAcGFyYW0ge251bWJlcltdfSBvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgdmFyIG9sZE9mZnNldCA9IG9mZnNldDtcbiAgICB3aGlsZSAobnVtID49IElOVCkge1xuICAgICAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCO1xuICAgICAgICBudW0gLz0gMTI4O1xuICAgIH1cbiAgICB3aGlsZSAobnVtICYgTVNCQUxMKSB7XG4gICAgICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0I7XG4gICAgICAgIG51bSA+Pj49IDc7XG4gICAgfVxuICAgIG91dFtvZmZzZXRdID0gbnVtIHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIGRlY29kZSA9IHJlYWQ7XG52YXIgTVNCJDEgPSAweDgwLCBSRVNUJDEgPSAweDdGO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IGFueVtdfSBidWZcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICAgIHZhciByZXMgPSAwLCBvZmZzZXQgPSBvZmZzZXQgfHwgMCwgc2hpZnQgPSAwLCBjb3VudGVyID0gb2Zmc2V0LCBiLCBsID0gYnVmLmxlbmd0aDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYiA9IGJ1Zltjb3VudGVyKytdO1xuICAgICAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgICAgICAgPyAoYiAmIFJFU1QkMSkgPDwgc2hpZnRcbiAgICAgICAgICAgIDogKGIgJiBSRVNUJDEpICogTWF0aC5wb3coMiwgc2hpZnQpO1xuICAgICAgICBzaGlmdCArPSA3O1xuICAgIH0gd2hpbGUgKGIgPj0gTVNCJDEpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldDtcbiAgICByZXR1cm4gcmVzO1xufVxudmFyIE4xID0gTWF0aC5wb3coMiwgNyk7XG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNCk7XG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSk7XG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOCk7XG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSk7XG52YXIgTjYgPSBNYXRoLnBvdygyLCA0Mik7XG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSk7XG52YXIgTjggPSBNYXRoLnBvdygyLCA1Nik7XG52YXIgTjkgPSBNYXRoLnBvdygyLCA2Myk7XG52YXIgbGVuZ3RoID0gZnVuY3Rpb24gKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPCBOMSA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IE4yID8gMlxuICAgICAgICAgICAgOiB2YWx1ZSA8IE4zID8gM1xuICAgICAgICAgICAgICAgIDogdmFsdWUgPCBONCA/IDRcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA8IE41ID8gNVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA8IE42ID8gNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgPCBONyA/IDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA8IE44ID8gOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA8IE45ID8gOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTApO1xufTtcbnZhciB2YXJpbnQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGVfMSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGluZ0xlbmd0aDogbGVuZ3RoXG59O1xudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcbmV4cG9ydCBkZWZhdWx0IF9icnJwX3ZhcmludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhcmludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/node_modules/multiformats/dist/src/vendor/varint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/api.js":
/*!********************************************!*\
  !*** ./node_modules/@perma/map/src/api.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvYXBpLmpzIiwibWFwcGluZ3MiOiI7QUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvc3JjL2FwaS5qcz81YTdlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/bitfield/Uint32.js":
/*!********************************************************!*\
  !*** ./node_modules/@perma/map/src/bitfield/Uint32.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: () => (/* reexport module object */ _api_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   bitCount: () => (/* binding */ bitCount),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   popcount: () => (/* binding */ popcount),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/api.js\");\n\n\n\n\n/**\n * @param {API.Uint32} size\n */\nconst empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`)\n  }\n\n  return 0\n}\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nconst from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit)\n  }\n  return bitfield\n}\n\n/**\n * @param {API.Uint32} _bitField\n */\nconst size = _bitField => 32\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => (bitField >>> index) & 0b11111\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index)\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst popcount = (bitField, index = 31) =>\n  bitCount(bitField & (offset(index, 0) - 1))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nconst set = (bitField, index) => bitField | (1 << index)\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nconst unset = (bitField, index) => bitField & (0xff ^ (1 << index))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nconst get = (bitField, index) => ((bitField >> index) & 0x1) !== 0\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nconst bitCount = bitField => {\n  const n1 = bitField - ((bitField >> 1) & 0x55555555)\n  const n2 = (n1 & 0x33333333) + ((n1 >> 2) & 0x33333333)\n  const n3 = ((n2 + (n2 >> 4)) & 0xf0f0f0f) * 0x1010101\n  return n3 >> 24\n}\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nconst and = (left, right) => left & right\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nconst or = (left, right) => left | right\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nconst toBytes = bitField =>\n  Uint8Array.of(\n    (bitField >> 24) & 0b1111_1111,\n    (bitField >> 16) & 0b1111_1111,\n    (bitField >> 8) & 0b1111_1111,\n    bitField & 0b1111_1111\n  )\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nconst fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`)\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvYml0ZmllbGQvVWludDMyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCOztBQUVqQjs7QUFFZDtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUs7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQixXQUFXLFlBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL3NyYy9iaXRmaWVsZC9VaW50MzIuanM/ZjZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBUEkgZnJvbSBcIi4vYXBpLmpzXCJcblxuZXhwb3J0IHsgQVBJIH1cblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IHNpemVcbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gKHNpemUgPSAzMikgPT4ge1xuICAvLyBXZSBjb3VsZCBzdXBwb3J0IDwgMzIsIGJ1dCBpdCBzZWVtcyBpbXByYWN0aWNhbCBhbmQgd291bGQgbmVnYXRpdmVseSBhZmZlY3RcbiAgLy8gcGVyZm9ybWFuY2UgYXMgd2Ugd291bGQgaGF2ZSB0byBkbyBleHRyYSBib3VuZCBjaGVja3MuXG4gIGlmIChzaXplICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVWludDMyIEJpdEZpZWxkIGRvZXMgbm90IHN1cHBvcnQgc2l6ZTogJHtzaXplfWApXG4gIH1cblxuICByZXR1cm4gMFxufVxuXG4vKipcbiAqIEBwYXJhbSAge0FQSS5VaW50MzJbXX0gYml0c1xuICogQHBhcmFtIHtBUEkuVWludDMyfSBbc2l6ZV1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoYml0cywgc2l6ZSkgPT4ge1xuICBsZXQgYml0ZmllbGQgPSBlbXB0eShzaXplKVxuICBmb3IgKGNvbnN0IGJpdCBvZiBiaXRzKSB7XG4gICAgYml0ZmllbGQgPSBzZXQoYml0ZmllbGQsIGJpdClcbiAgfVxuICByZXR1cm4gYml0ZmllbGRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IF9iaXRGaWVsZFxuICovXG5leHBvcnQgY29uc3Qgc2l6ZSA9IF9iaXRGaWVsZCA9PiAzMlxuXG4vKipcbiAqIFJlYWRzIG91dCA1IGJpdHMgYXQgdGhlIGdpdmVuIGJpdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtBUEkuVWludDMyfSBiaXRGaWVsZCAtIEJpdGZpZWxkIGluIFVpbnQzMiByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gaW5kZXggLSBJbmRleCB3aXRoLWluIGBiaXRGaWVsZGAgdG8gcmVhZCBiaXRzIGZyb20uXG4gKiBAcmV0dXJucyB7QVBJLlVpbnQzMn1cbiAqL1xuY29uc3QgbWFzayA9IChiaXRGaWVsZCwgaW5kZXgpID0+IChiaXRGaWVsZCA+Pj4gaW5kZXgpICYgMGIxMTExMVxuXG4vKipcbiAqIENyZWF0ZXMgbWFzayB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGEgYml0IGluIG5vZGVzIGJpdG1hcCBmb3IgdGhlIGdpdmVcbiAqIGtleSAoaGFzaCkgYXQgZ2l2ZW4gZGVwdGguXG4gKlxuICogQHBhcmFtIHtBUEkuVWludDMyfSBiaXRGaWVsZCAtIEtleSBoYXNoIGFzIDMyIGJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIHtBUEkuVWludDMyfSBpbmRleCAtIEluZGV4IHdpdGgtaW4gdGhlIDMyYml0IGJpdGZpZWxkXG4gKi9cbmNvbnN0IG9mZnNldCA9IChiaXRGaWVsZCwgaW5kZXgpID0+IDEgPDwgbWFzayhiaXRGaWVsZCwgaW5kZXgpXG5cbi8qKlxuICogTWFwcyBudW1iZXJzIFswLCAzMV0gdG8gcG93ZXJzIG9mIHR3by4gQ3JlYXRlcyBtYXNrIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGNoZWNrIGEgYml0IGluIG5vZGVzIGJpdG1hcCBmb3IgdGhlIGdpdmUga2V5IChoYXNoKSBhdCBnaXZlbiBkZXB0aC5cbiAqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGJpdEZpZWxkIC0gS2V5IGhhc2ggYXMgMzIgYml0IGludGVnZXIuXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGluZGV4IC0gSW5kZXggd2l0aC1pbiB0aGUgMzJiaXQgYml0ZmllbGRcbiAqL1xuZXhwb3J0IGNvbnN0IHBvcGNvdW50ID0gKGJpdEZpZWxkLCBpbmRleCA9IDMxKSA9PlxuICBiaXRDb3VudChiaXRGaWVsZCAmIChvZmZzZXQoaW5kZXgsIDApIC0gMSkpXG5cbi8qKlxuICogQHBhcmFtIHtBUEkuVWludDMyfSBiaXRGaWVsZFxuICogQHBhcmFtIHtBUEkuVWludDMyfSBpbmRleFxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gKGJpdEZpZWxkLCBpbmRleCkgPT4gYml0RmllbGQgfCAoMSA8PCBpbmRleClcblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGJpdEZpZWxkXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCB1bnNldCA9IChiaXRGaWVsZCwgaW5kZXgpID0+IGJpdEZpZWxkICYgKDB4ZmYgXiAoMSA8PCBpbmRleCkpXG5cbi8qKlxuICogQHBhcmFtIHtBUEkuVWludDMyfSBiaXRGaWVsZFxuICogQHBhcmFtIHtBUEkuVWludDMyfSBpbmRleFxuICovXG5leHBvcnQgY29uc3QgZ2V0ID0gKGJpdEZpZWxkLCBpbmRleCkgPT4gKChiaXRGaWVsZCA+PiBpbmRleCkgJiAweDEpICE9PSAwXG5cbi8qKlxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgYml0cyBzZXQgaW4gblxuICogQHBhcmFtIHtBUEkuVWludDMyfSBiaXRGaWVsZFxuICovXG5leHBvcnQgY29uc3QgYml0Q291bnQgPSBiaXRGaWVsZCA9PiB7XG4gIGNvbnN0IG4xID0gYml0RmllbGQgLSAoKGJpdEZpZWxkID4+IDEpICYgMHg1NTU1NTU1NSlcbiAgY29uc3QgbjIgPSAobjEgJiAweDMzMzMzMzMzKSArICgobjEgPj4gMikgJiAweDMzMzMzMzMzKVxuICBjb25zdCBuMyA9ICgobjIgKyAobjIgPj4gNCkpICYgMHhmMGYwZjBmKSAqIDB4MTAxMDEwMVxuICByZXR1cm4gbjMgPj4gMjRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGxlZnRcbiAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gcmlnaHRcbiAqIEByZXR1cm5zIHtBUEkuVWludDMyfVxuICovXG5leHBvcnQgY29uc3QgYW5kID0gKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICYgcmlnaHRcblxuLyoqXG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGxlZnRcbiAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gcmlnaHRcbiAqIEByZXR1cm5zIHtBUEkuVWludDMyfVxuICovXG5leHBvcnQgY29uc3Qgb3IgPSAobGVmdCwgcmlnaHQpID0+IGxlZnQgfCByaWdodFxuXG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGJpdHMgc2V0IGluIG5cbiAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gYml0RmllbGRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgdG9CeXRlcyA9IGJpdEZpZWxkID0+XG4gIFVpbnQ4QXJyYXkub2YoXG4gICAgKGJpdEZpZWxkID4+IDI0KSAmIDBiMTExMV8xMTExLFxuICAgIChiaXRGaWVsZCA+PiAxNikgJiAwYjExMTFfMTExMSxcbiAgICAoYml0RmllbGQgPj4gOCkgJiAwYjExMTFfMTExMSxcbiAgICBiaXRGaWVsZCAmIDBiMTExMV8xMTExXG4gIClcblxuLyoqXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge0FQSS5VaW50MzJ9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQnl0ZXMgPSBieXRlcyA9PiB7XG4gIGlmIChieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIDQgYnl0ZXMgaW5zdGVhZCBnb3QgJHtieXRlcy5sZW5ndGh9YClcbiAgfVxuICByZXR1cm4gKGJ5dGVzWzBdIDw8IDI0KSArIChieXRlc1sxXSA8PCAxNikgKyAoYnl0ZXNbMl0gPDwgOCkgKyBieXRlc1szXVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/bitfield/Uint32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/bitfield/Uint8Array.js":
/*!************************************************************!*\
  !*** ./node_modules/@perma/map/src/bitfield/Uint8Array.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: () => (/* reexport module object */ _api_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   popcount: () => (/* binding */ popcount),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var _Uint32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Uint32.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/Uint32.js\");\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/api.js\");\n\n\n\n/**\n * @param {number} size\n */\nconst empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`)\n  }\n\n  return new Uint8Array(size / 8)\n}\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nconst from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const index of bits) {\n    const { byte, byteOffset, bitOffset } = at(bitfield, index)\n    bitfield[byteOffset] = byte | (1 << bitOffset)\n  }\n  return bitfield\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nconst size = bitfield => bitfield.byteLength * 8\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - ((index / 8) | 0)\n  const bitOffset = index % 8\n  const byte = bitfield[byteOffset]\n\n  return { byte, byteOffset, bitOffset }\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0)\n    result[index] = byte\n    return result\n  }\n  return bytes\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nconst set = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte | (1 << bitOffset))\n}\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nconst unset = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte & (0xff ^ (1 << bitOffset)))\n}\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst get = (bitfield, index) => {\n  var { byte, bitOffset } = at(bitfield, index)\n  return ((byte >> bitOffset) & 0x1) !== 0\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nconst toBytes = bitfield => bitfield\n\n/**\n * @param {Uint8Array} bytes\n */\nconst fromBytes = bytes => bytes\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const { byteOffset, bitOffset, byte } = at(bitfield, index)\n\n  let count = (0,_Uint32_js__WEBPACK_IMPORTED_MODULE_0__.popcount)(byte, bitOffset)\n  let offset = bitfield.byteLength - 1\n  while (offset > byteOffset) {\n    const byte = bitfield[offset]\n    count += (0,_Uint32_js__WEBPACK_IMPORTED_MODULE_0__.bitCount)(byte)\n    offset--\n  }\n\n  return count\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nconst or = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] |= right[offset]\n    offset++\n  }\n  return result\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nconst and = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] &= right[offset]\n    offset++\n  }\n  return result\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvYml0ZmllbGQvVWludDhBcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUMvQjs7QUFFL0I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1AsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUCxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087O0FBRVA7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQLFVBQVUsOEJBQThCOztBQUV4QyxjQUFjLG9EQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL3NyYy9iaXRmaWVsZC9VaW50OEFycmF5LmpzPzgwYTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYml0Q291bnQsIHBvcGNvdW50IGFzIHBvcGNvdW50MzIgfSBmcm9tIFwiLi9VaW50MzIuanNcIlxuaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL2FwaS5qc1wiXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gKHNpemUgPSAyNTYpID0+IHtcbiAgaWYgKHNpemUgJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGJlIG11bHRpcGxlIG9mIDhgKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUgLyA4KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYml0ZmllbGQgd2l0aCBzcGVjaWZpYyBiaXRzIHNldC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBiaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoYml0cywgc2l6ZSkgPT4ge1xuICBsZXQgYml0ZmllbGQgPSBlbXB0eShzaXplKVxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGJpdHMpIHtcbiAgICBjb25zdCB7IGJ5dGUsIGJ5dGVPZmZzZXQsIGJpdE9mZnNldCB9ID0gYXQoYml0ZmllbGQsIGluZGV4KVxuICAgIGJpdGZpZWxkW2J5dGVPZmZzZXRdID0gYnl0ZSB8ICgxIDw8IGJpdE9mZnNldClcbiAgfVxuICByZXR1cm4gYml0ZmllbGRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJpdGZpZWxkXG4gKi9cbmV4cG9ydCBjb25zdCBzaXplID0gYml0ZmllbGQgPT4gYml0ZmllbGQuYnl0ZUxlbmd0aCAqIDhcblxuLyoqXG4gKiBDb21wdXRlIG9mZnNldCBmb3IgdGhlIGdpdmVuIGluZGV4XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiaXRmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IGF0ID0gKGJpdGZpZWxkLCBpbmRleCkgPT4ge1xuICBjb25zdCBieXRlT2Zmc2V0ID0gYml0ZmllbGQuYnl0ZUxlbmd0aCAtIDEgLSAoKGluZGV4IC8gOCkgfCAwKVxuICBjb25zdCBiaXRPZmZzZXQgPSBpbmRleCAlIDhcbiAgY29uc3QgYnl0ZSA9IGJpdGZpZWxkW2J5dGVPZmZzZXRdXG5cbiAgcmV0dXJuIHsgYnl0ZSwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0IH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwYXJ0aWN1bGFyIGJpdC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3Qgc2V0Qnl0ZSA9IChieXRlcywgaW5kZXgsIGJ5dGUpID0+IHtcbiAgaWYgKGJ5dGVzW2luZGV4XSAhPT0gYnl0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJ5dGVzLnNsaWNlKDApXG4gICAgcmVzdWx0W2luZGV4XSA9IGJ5dGVcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8qKlxuICogU2V0IGEgcGFydGljdWxhciBiaXQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiaXRmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IChiaXRmaWVsZCwgaW5kZXgpID0+IHtcbiAgY29uc3QgeyBieXRlLCBieXRlT2Zmc2V0LCBiaXRPZmZzZXQgfSA9IGF0KGJpdGZpZWxkLCBpbmRleClcbiAgcmV0dXJuIHNldEJ5dGUoYml0ZmllbGQsIGJ5dGVPZmZzZXQsIGJ5dGUgfCAoMSA8PCBiaXRPZmZzZXQpKVxufVxuXG4vKipcbiAqIFVuc2V0cyBhIHBhcnRpY3VsYXIgYml0LlxuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJpdGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgdW5zZXQgPSAoYml0ZmllbGQsIGluZGV4KSA9PiB7XG4gIGNvbnN0IHsgYnl0ZSwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0IH0gPSBhdChiaXRmaWVsZCwgaW5kZXgpXG4gIHJldHVybiBzZXRCeXRlKGJpdGZpZWxkLCBieXRlT2Zmc2V0LCBieXRlICYgKDB4ZmYgXiAoMSA8PCBiaXRPZmZzZXQpKSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBiaXQgYXQgZ2l2ZW4gaW5kZXggaXMgc2V0LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYml0ZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5leHBvcnQgY29uc3QgZ2V0ID0gKGJpdGZpZWxkLCBpbmRleCkgPT4ge1xuICB2YXIgeyBieXRlLCBiaXRPZmZzZXQgfSA9IGF0KGJpdGZpZWxkLCBpbmRleClcbiAgcmV0dXJuICgoYnl0ZSA+PiBiaXRPZmZzZXQpICYgMHgxKSAhPT0gMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYml0ZmllbGRcbiAqL1xuZXhwb3J0IGNvbnN0IHRvQnl0ZXMgPSBiaXRmaWVsZCA9PiBiaXRmaWVsZFxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21CeXRlcyA9IGJ5dGVzID0+IGJ5dGVzXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiaXRmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCBwb3Bjb3VudCA9IChiaXRmaWVsZCwgaW5kZXggPSBiaXRmaWVsZC5ieXRlTGVuZ3RoICogOCkgPT4ge1xuICBjb25zdCB7IGJ5dGVPZmZzZXQsIGJpdE9mZnNldCwgYnl0ZSB9ID0gYXQoYml0ZmllbGQsIGluZGV4KVxuXG4gIGxldCBjb3VudCA9IHBvcGNvdW50MzIoYnl0ZSwgYml0T2Zmc2V0KVxuICBsZXQgb2Zmc2V0ID0gYml0ZmllbGQuYnl0ZUxlbmd0aCAtIDFcbiAgd2hpbGUgKG9mZnNldCA+IGJ5dGVPZmZzZXQpIHtcbiAgICBjb25zdCBieXRlID0gYml0ZmllbGRbb2Zmc2V0XVxuICAgIGNvdW50ICs9IGJpdENvdW50KGJ5dGUpXG4gICAgb2Zmc2V0LS1cbiAgfVxuXG4gIHJldHVybiBjb3VudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbGVmdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByaWdodFxuICovXG5leHBvcnQgY29uc3Qgb3IgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gbGVmdC5zbGljZSgpXG4gIGxldCBvZmZzZXQgPSAwXG4gIHdoaWxlIChvZmZzZXQgPCBsZWZ0Lmxlbmd0aCkge1xuICAgIHJlc3VsdFtvZmZzZXRdIHw9IHJpZ2h0W29mZnNldF1cbiAgICBvZmZzZXQrK1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGxlZnRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGFuZCA9IChsZWZ0LCByaWdodCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBsZWZ0LnNsaWNlKClcbiAgbGV0IG9mZnNldCA9IDBcbiAgd2hpbGUgKG9mZnNldCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgcmVzdWx0W29mZnNldF0gJj0gcmlnaHRbb2Zmc2V0XVxuICAgIG9mZnNldCsrXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgeyBBUEkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/bitfield/Uint8Array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/bitfield/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/@perma/map/src/bitfield/api.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvYml0ZmllbGQvYXBpLmpzIiwibWFwcGluZ3MiOiI7QUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvc3JjL2JpdGZpZWxkL2FwaS5qcz8wNzE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/bitfield/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/lib.js":
/*!********************************************!*\
  !*** ./node_modules/@perma/map/src/lib.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   builder: () => (/* binding */ builder),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   has: () => (/* binding */ has)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/api.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ \"(ssr)/./node_modules/@perma/map/src/node.js\");\n/* harmony import */ var _path_Uint32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path/Uint32.js */ \"(ssr)/./node_modules/@perma/map/src/path/Uint32.js\");\n/* harmony import */ var _path_Uint8Array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path/Uint8Array.js */ \"(ssr)/./node_modules/@perma/map/src/path/Uint8Array.js\");\n/* harmony import */ var _bitfield_Uint32_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bitfield/Uint32.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/Uint32.js\");\n/* harmony import */ var _bitfield_Uint8Array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bitfield/Uint8Array.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/Uint8Array.js\");\n\n;\n\n\n\n\n\n\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nconst empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, (0,_node_js__WEBPACK_IMPORTED_MODULE_1__.create)(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? _bitfield_Uint32_js__WEBPACK_IMPORTED_MODULE_4__ : _bitfield_Uint8Array_js__WEBPACK_IMPORTED_MODULE_5__,\n  Path = bitWidth === 5\n    ? _path_Uint32_js__WEBPACK_IMPORTED_MODULE_2__.configure({ bitWidth })\n    : _path_Uint8Array_js__WEBPACK_IMPORTED_MODULE_3__.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nconst from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nconst has = (hamt, key) =>\n  _node_js__WEBPACK_IMPORTED_MODULE_1__.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nconst get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  _node_js__WEBPACK_IMPORTED_MODULE_1__.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nconst builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    (0,_node_js__WEBPACK_IMPORTED_MODULE_1__.create)(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      (0,_node_js__WEBPACK_IMPORTED_MODULE_1__.create)(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return _node_js__WEBPACK_IMPORTED_MODULE_1__.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = _node_js__WEBPACK_IMPORTED_MODULE_1__.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = _node_js__WEBPACK_IMPORTED_MODULE_1__[\"delete\"](this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = _node_js__WEBPACK_IMPORTED_MODULE_1__.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = _node_js__WEBPACK_IMPORTED_MODULE_1__[\"delete\"](this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ3hCLENBQWlDO0FBQzRCO0FBQzlCO0FBQ2U7QUFDUTtBQUNBO0FBQ1E7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQSxrQ0FBa0MsZ0RBQXVCO0FBQ3pEOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQWMsR0FBRyxvREFBa0I7QUFDakU7QUFDQSxNQUFNLHNEQUFvQixHQUFHLFVBQVU7QUFDdkMsTUFBTSwwREFBd0IsR0FBRyxVQUFVO0FBQzNDLEVBQUUsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLDBCQUEwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTztBQUNQLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLEdBQUc7QUFDZDtBQUNPO0FBQ1AsRUFBRSx5Q0FBUTs7QUFFVjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ08sOENBQThDLEdBQUc7QUFDeEQsRUFBRSx5Q0FBUTs7QUFFVjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsWUFBWTtBQUMxQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBdUI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGdDQUFnQztBQUM3QyxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdEQUF1QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVcseUNBQVE7QUFDbkI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsaUJBQWlCLHlDQUFRO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFXLHlCQUF5QixjQUFjOztBQUVuRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGdDQUFnQztBQUM3QyxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixtQkFBbUIseUNBQVE7O0FBRTNCO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG1CQUFtQiwrQ0FBVzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvbGliLmpzP2U2NDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vYXBpLmpzXCJcbmltcG9ydCAqIGFzIE5vZGUgZnJvbSBcIi4vbm9kZS5qc1wiXG5pbXBvcnQgeyBjcmVhdGUgYXMgY3JlYXRlQml0bWFwSW5kZXhlZE5vZGUgfSBmcm9tIFwiLi9ub2RlLmpzXCJcbmltcG9ydCAqIGFzIEFQSSBmcm9tIFwiLi9hcGkuanNcIlxuaW1wb3J0ICogYXMgVWludDMyUGF0aCBmcm9tIFwiLi9wYXRoL1VpbnQzMi5qc1wiXG5pbXBvcnQgKiBhcyBVaW50OEFycmF5UGF0aCBmcm9tIFwiLi9wYXRoL1VpbnQ4QXJyYXkuanNcIlxuaW1wb3J0ICogYXMgVWludDMyQml0RmllbGQgZnJvbSBcIi4vYml0ZmllbGQvVWludDMyLmpzXCJcbmltcG9ydCAqIGFzIFVpbnQ4QXJyYXlCaXRGaWVsZCBmcm9tIFwiLi9iaXRmaWVsZC9VaW50OEFycmF5LmpzXCJcblxuY29uc3QgTk9UX0ZPVU5EID0gbmV3IFJhbmdlRXJyb3IoXCJOb3QgRm91bmRcIilcblxuLyoqXG4gKiBBIGBiaXRXaWR0aGAgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGJpdHMgb2YgdGhlIGhhc2ggdG8gdXNlIGZvciBpbmRleFxuICogY2FsY3VsYXRpb24gYXQgZWFjaCBsZXZlbCBvZiB0aGUgdHJlZS4gSW4gZmlyc3QgbGF5ZXIgd2lsbCBkaXN0cmlidXRlXG4gKiBjaGlsZHJlbiBieSB0aGUgZmlyc3QgYGJpdFdpZHRoYCBiaXRzIG9mIHRoZSBrZXkgaGFzaC4gSW4gdGhlIG5leHQgbGF5ZXJcbiAqIG5leHQgYGJpdFdpZHRoYCBudW1iZXIgb2YgYml0cyBvZiB0aGUga2V5IGhhc2ggYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiBwbGFjZW1lbnQgb2YgaXQncyBjaGlsZHJlbiBhbmQgc28gb24uIEVhY2ggbm9kZSBpbiB0aGUgdHJlZSB3aWxsIGhvbGRcbiAqIGAyICoqIGJpdFdpZHRoYCBudW1iZXIgb2YgZWxlbWVudHMuXG4gKlxuICogRm9yIGV4YW1wbGUgd2hlbiB3ZSBpbnNlcnQgYW4gZW50cnkgbmFtZWQgYHJlc3VsdGAgaXQgd2lsbCBnZW5lcmF0ZSBhXG4gKiBmb2xvd2luZyBoYXNoICh3aXRoIG11cm11cjMgMzIpIGA0NDIwNjQ2OTBgIHdoaWNoIGluIGJpbmFyeSB3b3VsZCBiZVxuICpcbiAqIGBgYFxuICogMTEwMTAwMTAxMTAwMTAxMDExMTExMDAxMTAwMTBcbiAqIGBgYFxuICpcbiAqIFdoaWNoIHdpbGwgY29ycmVzcG9uZCB0byBhIGZvbGxvd2luZyBrZXkgcGF0aFxuICpcbiAqIGBgYFxuICogMTEwMTAvMDEwMTEvMDAxMDEvMDExMTEvMTAwMTEvMDAxMFxuICogYGBgXG4gKlxuICogV2hpcyBpbiBkZWNpbWFscyB3b3VsZCBiZVxuICpcbiAqIGBgYHRzXG4gKiAyNi8xMS81LzE1LzE5LzInXG4gKiBgYGBcbiAqXG4gKiBJZiB3ZSB0aGVuIGluc2VydCBgZmlzaGAgaXQgd291bGQgcHJvZHVjZSBmb2xsb3dpbmcgcGF0aFxuICpcbiAqIGBgYHRzXG4gKiAyNi8zLzQvMTgvMjgvMTkvMVxuICogYGBgXG4gKiBAdGVtcGxhdGUgW1Y9dW5rbm93bl1cbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBbSz1zdHJpbmddXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IFtDPUFQSS5Db25maWc8QVBJLlVpbnQzMj5dXG4gKiBAcGFyYW0ge1BhcnRpYWw8Qz59IFtvcHRpb25zXVxuICogQHJldHVybnMge0FQSS5QZXJzaXN0ZW50SGFzaE1hcDxWLCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3VyZShvcHRpb25zKVxuICByZXR1cm4gbmV3IFBlcnNpc3RlbnRIYXNoTWFwKDAsIGNyZWF0ZUJpdG1hcEluZGV4ZWROb2RlKGNvbmZpZywgbnVsbCksIGNvbmZpZylcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IFtDPUFQSS5Db25maWc8QVBJLlVpbnQzMj5dXG4gKiBAcGFyYW0ge1BhcnRpYWw8Qz59IGNvbmZpZ1xuICogQHJldHVybnMge0N9XG4gKi9cbmNvbnN0IGNvbmZpZ3VyZSA9ICh7XG4gIGJpdFdpZHRoID0gNSxcbiAgLyogYzggaWdub3JlIG5leHQgNCAqL1xuICBCaXRGaWVsZCA9IGJpdFdpZHRoID09PSA1ID8gVWludDMyQml0RmllbGQgOiBVaW50OEFycmF5Qml0RmllbGQsXG4gIFBhdGggPSBiaXRXaWR0aCA9PT0gNVxuICAgID8gVWludDMyUGF0aC5jb25maWd1cmUoeyBiaXRXaWR0aCB9KVxuICAgIDogVWludDhBcnJheVBhdGguY29uZmlndXJlKHsgYml0V2lkdGggfSksXG59ID0ge30pID0+IC8qKiBAdHlwZSB7Q30gKi8gKHsgYml0V2lkdGgsIEJpdEZpZWxkLCBQYXRoIH0pXG5cbi8qKlxuICogQ3JlYXRlcyBIYXNoTWFwIGZyb20gdGhlIHByb3ZpZGVkIGVudHJpZXMuXG4gKlxuICogQHRlbXBsYXRlIFtWPXVua25vd25dXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gW0s9c3RyaW5nXVxuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBbQz1BUEkuQ29uZmlnPEFQSS5VaW50MzI+XVxuICogQHBhcmFtIHtJdGVyYWJsZTxbSywgVl0+fSBlbnRyaWVzXG4gKiBAcGFyYW0ge1BhcnRpYWw8Qz59IFtvcHRpb25zXVxuICogQHJldHVybnMge0FQSS5QZXJzaXN0ZW50SGFzaE1hcDxWLCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoZW50cmllcywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtBUEkuSGFzaE1hcEJ1aWxkZXI8ViwgSywgQz59ICovIChidWlsZGVyKG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgbm9kZS5zZXQoa2V5LCB2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiBub2RlLmJ1aWxkKClcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEBwYXJhbSB7QVBJLkhBTVQ8VCwgSz59IGhhbXRcbiAqIEBwYXJhbSB7S30ga2V5XG4gKi9cbmV4cG9ydCBjb25zdCBoYXMgPSAoaGFtdCwga2V5KSA9PlxuICBOb2RlLmdldChoYW10LnJvb3QsIGtleSwgTk9UX0ZPVU5EKSAhPT0gTk9UX0ZPVU5EXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUgW1U9dW5kZWZpbmVkXVxuICogQHBhcmFtIHtBUEkuSEFNVDxULCBLPn0gaGFtdFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7VX0gbm90Rm91bmRcbiAqIEByZXR1cm5zIHtUfFV9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAoaGFtdCwga2V5LCBub3RGb3VuZCA9IC8qKiBAdHlwZSB7VX0gKi8gKHVuZGVmaW5lZCkpID0+XG4gIE5vZGUuZ2V0KGhhbXQucm9vdCwga2V5LCBub3RGb3VuZClcblxuLyoqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtQYXJ0aWFsPEM+fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtBUEkuSGFzaE1hcEJ1aWxkZXI8VCwgSywgQz59XG4gKi9cbmV4cG9ydCBjb25zdCBidWlsZGVyID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGVkaXQgPSB7fVxuICBjb25zdCBjb25maWcgPSBjb25maWd1cmUob3B0aW9ucylcbiAgcmV0dXJuIG5ldyBIYXNoTWFwQnVpbGRlcihcbiAgICBlZGl0LFxuICAgIDAsXG4gICAgY3JlYXRlQml0bWFwSW5kZXhlZE5vZGUoY29uZmlnLCBlZGl0KSxcbiAgICBjb25maWdcbiAgKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAaW1wbGVtZW50cyB7QVBJLlBlcnNpc3RlbnRIYXNoTWFwPFQsIEssIEM+fVxuICovXG5jbGFzcyBQZXJzaXN0ZW50SGFzaE1hcCB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59IHJvb3RcbiAgICogQHBhcmFtIHtDfSBjb25maWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvdW50ID0gMCwgcm9vdCwgY29uZmlnKSB7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50XG4gICAgdGhpcy5yb290ID0gcm9vdFxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cblxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudFxuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50SGFzaE1hcCh0aGlzLmNvdW50LCB0aGlzLnJvb3QsIHRoaXMuY29uZmlnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBUEkuUGVyc2lzdGVudEhhc2hNYXA8VCwgSywgQz59XG4gICAqL1xuICBlbXB0eSgpIHtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRIYXNoTWFwKFxuICAgICAgMCxcbiAgICAgIGNyZWF0ZUJpdG1hcEluZGV4ZWROb2RlKHRoaXMuY29uZmlnLCBudWxsKSxcbiAgICAgIHRoaXMuY29uZmlnXG4gICAgKVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gaGFzKHRoaXMsIGtleSlcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtLfSBrZXlcbiAgICogQHJldHVybnMge1R8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBOb2RlLmdldCh0aGlzLnJvb3QsIGtleSwgdW5kZWZpbmVkKVxuICB9XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICAgKiBAcGFyYW0ge1J9IGtleVxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtQZXJzaXN0ZW50SGFzaE1hcDxULCBLfFIsIEM+fVxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBhZGRlZExlYWYgPSB7IHZhbHVlOiBmYWxzZSB9XG4gICAgY29uc3Qgcm9vdCA9IE5vZGUuc2V0KHRoaXMucm9vdCwgbnVsbCwga2V5LCB2YWx1ZSwgYWRkZWRMZWFmKVxuICAgIGlmIChyb290ID09PSB0aGlzLnJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVudEhhc2hNYXAoXG4gICAgICAgIGFkZGVkTGVhZi52YWx1ZSA/IHRoaXMuY291bnQgKyAxIDogdGhpcy5jb3VudCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgdGhpcy5jb25maWdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7S30ga2V5XG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3Qgcm9vdCA9IE5vZGUuZGVsZXRlKHRoaXMucm9vdCwgbnVsbCwga2V5LCB7IHZhbHVlOiBmYWxzZSB9KVxuXG4gICAgaWYgKHJvb3QgPT09IHRoaXMucm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50SGFzaE1hcCh0aGlzLmNvdW50IC0gMSwgcm9vdCwgdGhpcy5jb25maWcpXG4gICAgfVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBnZXQgYml0RmllbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLkJpdEZpZWxkLm9yKHRoaXMucm9vdC5kYXRhbWFwLCB0aGlzLnJvb3Qubm9kZW1hcClcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmVudHJpZXMoKVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5rZXlzKClcbiAgfVxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC52YWx1ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBUEkuSGFzaE1hcEJ1aWxkZXI8VCwgSywgQz59XG4gICAqL1xuXG4gIGNyZWF0ZUJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBIYXNoTWFwQnVpbGRlcih7fSwgdGhpcy5jb3VudCwgdGhpcy5yb290LCB0aGlzLmNvbmZpZylcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKi9cbmNsYXNzIEhhc2hNYXBCdWlsZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QVBJLkVkaXR9IGVkaXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEBwYXJhbSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fSByb290XG4gICAqIEBwYXJhbSB7Q30gY29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlZGl0LCBjb3VudCwgcm9vdCwgY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FQSS5FZGl0fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVkaXQgPSBlZGl0XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ID0gY291bnRcbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgfVxuXG4gIGdldCBzaXplKCkge1xuICAgIGlmICh0aGlzLmVkaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvdW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgLnNpemUgd2FzIGFjY2Vzc2VkIG9uIHRoZSBmaW5hbGl6ZWQgYnVpbGRlcmApXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICAgKiBAcGFyYW0ge1J9IGtleVxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtIYXNoTWFwQnVpbGRlcjxULCBLfFIsIEM+fVxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5lZGl0KSB7XG4gICAgICBjb25zdCBhZGRlZExlYWYgPSB7IHZhbHVlOiBmYWxzZSB9XG4gICAgICBjb25zdCByb290ID0gTm9kZS5zZXQodGhpcy5yb290LCB0aGlzLmVkaXQsIGtleSwgdmFsdWUsIGFkZGVkTGVhZilcblxuICAgICAgaWYgKHRoaXMucm9vdCAhPT0gcm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSAvKiogQHR5cGUge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gKi8gKHJvb3QpXG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRlZExlYWYudmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb3VudCArPSAxXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgLnNldCB3YXMgY2FsbGVkIG9uIHRoZSBmaW5hbGl6ZWQgYnVpbGRlcmApXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIGlmICh0aGlzLmVkaXQpIHtcbiAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBjb25zdCByZW1vdmVkTGVhZiA9IHsgdmFsdWU6IGZhbHNlIH1cbiAgICAgIGNvbnN0IHJvb3QgPSBOb2RlLmRlbGV0ZSh0aGlzLnJvb3QsIHRoaXMuZWRpdCwga2V5LCByZW1vdmVkTGVhZilcblxuICAgICAgaWYgKHJvb3QgIT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlZExlYWYudmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYC5kZWxldGUgd2FzIGNhbGxlZCBvbiB0aGUgZmluYWxpemVkIGJ1aWxkZXJgKVxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmVkaXQpIHtcbiAgICAgIHRoaXMuZWRpdCA9IG51bGxcbiAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVudEhhc2hNYXAodGhpcy5jb3VudCwgdGhpcy5yb290LCB0aGlzLmNvbmZpZylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAuYnVpbGQgd2FzIGNhbGxlZCBvbiB0aGUgZmluYWxpemVkIGJ1aWxkZXJgKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/node.js":
/*!*********************************************!*\
  !*** ./node_modules/@perma/map/src/node.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: () => (/* reexport module object */ _api_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   associate: () => (/* binding */ associate),\n/* harmony export */   associateCollision: () => (/* binding */ associateCollision),\n/* harmony export */   copyAndSetChild: () => (/* binding */ copyAndSetChild),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"delete\": () => (/* binding */ remove),\n/* harmony export */   dissociate: () => (/* binding */ dissociate),\n/* harmony export */   dissociateCollision: () => (/* binding */ dissociateCollision),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   fork: () => (/* binding */ fork),\n/* harmony export */   forkAndSet: () => (/* binding */ forkAndSet),\n/* harmony export */   forkCollision: () => (/* binding */ forkCollision),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   inlineChild: () => (/* binding */ inlineChild),\n/* harmony export */   keyAt: () => (/* binding */ keyAt),\n/* harmony export */   keyPosition: () => (/* binding */ keyPosition),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   lookup: () => (/* binding */ lookup),\n/* harmony export */   lookupCollision: () => (/* binding */ lookupCollision),\n/* harmony export */   mergeTwoLeaves: () => (/* binding */ mergeTwoLeaves),\n/* harmony export */   migrateLeafToBranch: () => (/* binding */ migrateLeafToBranch),\n/* harmony export */   resolveNode: () => (/* binding */ resolveNode),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   valueAt: () => (/* binding */ valueAt),\n/* harmony export */   valuePosition: () => (/* binding */ valuePosition),\n/* harmony export */   values: () => (/* binding */ values)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/api.js\");\n/* harmony import */ var _bitfield_Uint32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitfield/Uint32.js */ \"(ssr)/./node_modules/@perma/map/src/bitfield/Uint32.js\");\n/* harmony import */ var _path_Uint32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path/Uint32.js */ \"(ssr)/./node_modules/@perma/map/src/path/Uint32.js\");\n\n\n;\n\n\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit\n    this.config = config\n    this.datamap = datamap\n    this.nodemap = nodemap\n    this.children = children\n  }\n\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap)\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap)\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config)\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit)\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit\n    this.count = count\n    this.children = children\n    this.config = config\n  }\n  get nodeArity() {\n    return /** @type {0} */ (0)\n  }\n  get dataArity() {\n    return this.count\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */ (forkCollision(this, edit))\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nconst lookupCollision = (node, name, notFound) => {\n  const { children: entries, count } = node\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name)\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? /** @type {T} */ (entries[n + 1]) : notFound\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nconst associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const { children, count } = node\n\n  const index = findHashCollisionNodeIndex(children, count, name)\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit)\n    addedLeaf.value = true\n    newNode.count += 1\n    newNode.children.splice(index, key, value)\n    return newNode\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit)\n    newNode.children[index + 1] = value\n    return newNode\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nconst dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const { children: entries, count, config } = node\n  const index = findHashCollisionNodeIndex(entries, count, name)\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node\n  } else {\n    removedLeaf.value = true\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n        associate(\n          create(config),\n          edit,\n          0,\n          hash,\n          /** @type {K} */ (entries[offset]),\n          /** @type {T} */ (entries[offset + 1]),\n          removedLeaf\n        )\n      )\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit)\n      newNode.children.splice(index, 2)\n      newNode.count -= 1\n      return newNode\n    }\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nconst forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    return new HashCollisionNode(\n      edit,\n      node.count,\n      /** @type {API.CollisionEntries<T, K>} */ (node.children.slice()),\n      node.config\n    )\n  }\n}\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2\n  }\n  return index\n}\n\nconst defaultConfig = { bitWidth: 32, BitField: _bitfield_Uint32_js__WEBPACK_IMPORTED_MODULE_1__, Path: _path_Uint32_js__WEBPACK_IMPORTED_MODULE_2__ }\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst create = (config, edit = null) =>\n  new BitmapIndexedNode(\n    edit,\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    /** @type {API.Children<T, K, C>} */ ([]),\n    config\n  )\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nconst get = (node, key, notFound) =>\n  lookup(node, 0, node.config.Path.from(key), key, notFound)\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nconst lookup = (node, depth, path, key, notFound) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index)\n    } else {\n      return notFound\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset)\n    return child.lookup(depth + 1, path, key, notFound)\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound\n  }\n}\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nconst set = (node, edit, key, value, addedLeaf) =>\n  associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf)\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nconst associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    const found = keyAt(node, index)\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value\n        ? node\n        : forkAndSet(node, edit, index, value)\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(\n        config,\n        edit,\n        depth + 1,\n        Path.from(found),\n        found,\n        valueAt(node, index),\n        path,\n        key,\n        value\n      )\n      addedLeaf.value = true\n\n      return migrateLeafToBranch(node, edit, offset, branch)\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset)\n    const newChild = child.associate(\n      edit,\n      depth + 1,\n      path,\n      key,\n      value,\n      addedLeaf\n    )\n\n    if (child === newChild) {\n      return node\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset)\n    addedLeaf.value = true\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit)\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset)\n    newNode.children.splice(keyPosition(index), 0, key, value)\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) =>\n  dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf)\n\n\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const { datamap, nodemap, config } = source\n  const { BitField, Path } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true\n      const node = fork(source, edit)\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset)\n      // remove the child\n      node.children.splice(keyPosition(index), 2)\n      return node\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset)\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf)\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source)\n        ? child\n        : inlineChild(source, edit, offset, child)\n    } else if (node === child) {\n      return source\n    } else {\n      return copyAndSetChild(source, edit, offset, child)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nconst entries = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      const value = children[offset]\n      yield /** @type {[K, T]} */ ([key, value])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n      children[offset]\n    )\n    yield* node.entries()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    const newNode = new BitmapIndexedNode(\n      edit,\n      node.datamap,\n      node.nodemap,\n      node.children.slice(),\n      node.config\n    )\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nconst keys = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      yield /** @type {K} */ (key)\n      offset += 2\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.keys()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nconst values = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      yield /** @type {T} */ (children[offset])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.values()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nconst forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit)\n  newNode.children[valuePosition(offset)] = value\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst inlineChild = (source, edit, offset, child) => {\n  const { datamap, nodemap, config } = source\n  const { BitField } = config\n  const node = fork(source, edit)\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1)\n  // add key-value pair where it wolud fall\n  node.children.splice(\n    keyPosition(BitField.popcount(datamap, offset)),\n    0,\n    child.children[0],\n    child.children[1]\n  )\n\n  node.datamap = BitField.set(datamap, offset)\n  node.nodemap = BitField.unset(nodemap, offset)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit)\n  newNode.children[nodePosition(node, offset)] = child\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst migrateLeafToBranch = (source, edit, offset, branch) => {\n  const { nodemap, datamap, config } = source\n  const { BitField } = config\n  const index = BitField.popcount(datamap, offset)\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index)\n  const newId = nodePosition(source, offset)\n\n  const node = fork(source, edit)\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset)\n  node.children.splice(oldId, 2)\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset)\n  node.children.splice(newId - 1, 0, branch)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nconst mergeTwoLeaves = (\n  config,\n  edit,\n  depth,\n  oldPath,\n  oldKey,\n  oldValue,\n  newPath,\n  newKey,\n  newValue\n) => {\n  const { BitField, Path } = config\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(\n      edit,\n      2,\n      [oldKey, oldValue, newKey, newValue],\n      config\n    )\n  } else {\n    const oldOffset = Path.at(oldPath, depth)\n    const newOffset = Path.at(newPath, depth)\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        BitField.from([oldOffset], Math.pow(2, config.bitWidth)),\n        [\n          mergeTwoLeaves(\n            config,\n            edit,\n            depth + 1,\n            oldPath,\n            oldKey,\n            oldValue,\n            newPath,\n            newKey,\n            newValue\n          ),\n        ],\n        config\n      )\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)),\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        /** @type {API.Children<T, K, C>} */\n        (\n          // We insert child with a lower index first so that we can derive it's\n          // index on access via popcount\n          oldOffset < newOffset\n            ? [oldKey, oldValue, newKey, newValue]\n            : [newKey, newValue, oldKey, oldValue]\n        ),\n        config\n      )\n    }\n  }\n}\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nconst keyAt = ({ children }, index) =>\n  /** @type {K} */ (children[keyPosition(index)])\n\n/**\n * @param {number} index\n */\nconst keyPosition = index => index * 2\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nconst valueAt = ({ children }, index) =>\n  /** @type {T} */ (children[valuePosition(index)])\n\n/**\n * @param {number} index\n */\nconst valuePosition = index => index * 2 + 1\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nconst resolveNode = (node, offset) =>\n  /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */ (\n    node.children[nodePosition(node, offset)]\n  )\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({ children, nodemap, config }, offset) =>\n  children.length - 1 - config.BitField.popcount(nodemap, offset)\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({ config: { BitField }, datamap, nodemap }) =>\n  BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNQO0FBQ3hCLENBQWdEO0FBQ1I7QUFDMUI7O0FBRWQ7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLG9DQUFvQztBQUNqRCxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFlBQVk7QUFDekIsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsR0FBRztBQUNoQixjQUFjLGdCQUFnQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsR0FBRztBQUNoQixjQUFjLGdCQUFnQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixHQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixhQUFhLGVBQWU7QUFDNUIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsS0FBSztBQUNsQixhQUFhLEdBQUc7QUFDaEIsY0FBYyxnQkFBZ0I7QUFDOUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsR0FBRztBQUNoQixjQUFjLGdCQUFnQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQjtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUCxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsUUFBUTtBQUN0QixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsR0FBRztBQUNkLFlBQVksZ0JBQWdCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUCxVQUFVLGtCQUFrQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxHQUFHO0FBQ2QsWUFBWSxnQkFBZ0I7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCLHdEQUFNO0FBQ3BEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDTztBQUNQLFVBQVUsMkJBQTJCO0FBQ3JDLFVBQVUsaUJBQWlCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxhQUFhLGtCQUFrQjtBQUMvQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsS0FBSztBQUNoQixXQUFXLEdBQUc7QUFDZCxZQUFZLGdCQUFnQjtBQUM1QixhQUFhO0FBQ2I7QUFDTztBQUNQLFVBQVUsMkJBQTJCO0FBQ3JDLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxrQ0FBa0M7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxhQUFhLGtCQUFrQjtBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUUyQjs7QUFFM0I7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLEdBQUc7QUFDZCxZQUFZLGdCQUFnQjtBQUM1QixhQUFhO0FBQ2I7QUFDTztBQUNQLFVBQVUsMkJBQTJCO0FBQ3JDLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ08sNkJBQTZCLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNPLDBCQUEwQixVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNPLDRCQUE0QixVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDTztBQUNQLFVBQVUsMkJBQTJCO0FBQ3JDLFVBQVUsV0FBVztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsVUFBVSwyQkFBMkI7QUFDckMsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxRQUFRO0FBQ25CO0FBQ08saUJBQWlCLFVBQVU7QUFDbEMsYUFBYSxHQUFHOztBQUVoQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFFBQVE7QUFDbkI7QUFDTyxtQkFBbUIsVUFBVTtBQUNwQyxhQUFhLEdBQUc7O0FBRWhCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1AsYUFBYSwrREFBK0Q7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixXQUFXLGdDQUFnQztBQUMzQyxXQUFXLFFBQVE7QUFDbkI7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLGFBQWE7QUFDYjtBQUNBLHlCQUF5QixVQUFVLFVBQVUsb0JBQW9CO0FBQ2pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvbm9kZS5qcz85NWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFQSSBmcm9tIFwiLi9hcGkuanNcIlxuZXhwb3J0ICogZnJvbSBcIi4vYXBpLmpzXCJcbmltcG9ydCAqIGFzIEJpdEZpZWxkIGZyb20gXCIuL2JpdGZpZWxkL1VpbnQzMi5qc1wiXG5pbXBvcnQgKiBhcyBQYXRoIGZyb20gXCIuL3BhdGgvVWludDMyLmpzXCJcbmV4cG9ydCB7IEFQSSB9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IENcbiAqIEBpbXBsZW1lbnRzIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gKi9cbmNsYXNzIEJpdG1hcEluZGV4ZWROb2RlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICAgKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snQml0RmllbGQnXVsnZW1wdHknXT59IGRhdGFtYXBcbiAgICogQHBhcmFtIHtSZXR1cm5UeXBlPENbJ0JpdEZpZWxkJ11bJ2VtcHR5J10+fSBub2RlbWFwXG4gICAqIEBwYXJhbSB7QVBJLkNoaWxkcmVuPFQsIEssIEM+fSBjaGlsZHJlblxuICAgKiBAcGFyYW0ge0N9IGNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoZWRpdCwgZGF0YW1hcCwgbm9kZW1hcCwgY2hpbGRyZW4sIGNvbmZpZykge1xuICAgIHRoaXMuZWRpdCA9IGVkaXRcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICAgIHRoaXMuZGF0YW1hcCA9IGRhdGFtYXBcbiAgICB0aGlzLm5vZGVtYXAgPSBub2RlbWFwXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuXG4gIH1cblxuICBnZXQgbm9kZUFyaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5CaXRGaWVsZC5wb3Bjb3VudCh0aGlzLm5vZGVtYXApXG4gIH1cbiAgZ2V0IGRhdGFBcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuQml0RmllbGQucG9wY291bnQodGhpcy5kYXRhbWFwKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gICAqL1xuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGVtcHR5KCkge1xuICAgIHJldHVybiBjcmVhdGUodGhpcy5jb25maWcpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFhcbiAgICogQHBhcmFtIHtBUEkuVWludDMyfSBkZXB0aFxuICAgKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snUGF0aCddWydmcm9tJ10+fSBwYXRoXG4gICAqIEBwYXJhbSB7S30ga2V5XG4gICAqIEBwYXJhbSB7WH0gbm90Rm91bmRcbiAgICogQHJldHVybnMge1R8WH1cbiAgICovXG5cbiAgbG9va3VwKGRlcHRoLCBwYXRoLCBrZXksIG5vdEZvdW5kKSB7XG4gICAgcmV0dXJuIGxvb2t1cCh0aGlzLCBkZXB0aCwgcGF0aCwga2V5LCBub3RGb3VuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICAgKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAgICogQHBhcmFtIHtBUEkuVWludDMyfSBkZXB0aFxuICAgKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snUGF0aCddWydmcm9tJ10+fSBwYXRoXG4gICAqIEBwYXJhbSB7S3xSfSBrZXlcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gYWRkZWRMZWFmXG4gICAqIEByZXR1cm5zIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSyB8IFIsIEM+fVxuICAgKi9cbiAgYXNzb2NpYXRlKGVkaXQsIGRlcHRoLCBwYXRoLCBrZXksIHZhbHVlLCBhZGRlZExlYWYpIHtcbiAgICByZXR1cm4gYXNzb2NpYXRlKHRoaXMsIGVkaXQsIGRlcHRoLCBwYXRoLCBrZXksIHZhbHVlLCBhZGRlZExlYWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gICAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gZGVwdGhcbiAgICogQHBhcmFtIHtSZXR1cm5UeXBlPENbJ1BhdGgnXVsnZnJvbSddPn0gcGF0aFxuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gcmVtb3ZlZExlYWZcbiAgICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn1cbiAgICovXG4gIGRpc3NvY2lhdGUoZWRpdCwgZGVwdGgsIHBhdGgsIGtleSwgcmVtb3ZlZExlYWYpIHtcbiAgICByZXR1cm4gZGlzc29jaWF0ZSh0aGlzLCBlZGl0LCBkZXB0aCwgcGF0aCwga2V5LCByZW1vdmVkTGVhZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAgICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn1cbiAgICovXG4gIGZvcmsoZWRpdCA9IG51bGwpIHtcbiAgICByZXR1cm4gZm9yayh0aGlzLCBlZGl0KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPFtLLCBUXT59XG4gICAqL1xuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8Sz59XG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiBrZXlzKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIHZhbHVlcyh0aGlzKVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IENcbiAqIEBpbXBsZW1lbnRzIHtBUEkuSGFzaENvbGxpc2lvbk5vZGU8VCwgSywgQz59XG4gKi9cbmNsYXNzIEhhc2hDb2xsaXNpb25Ob2RlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICogQHBhcmFtIHtBUEkuQ29sbGlzaW9uRW50cmllczxULCBLPn0gY2hpbGRyZW5cbiAgICogQHBhcmFtIHtDfSBjb25maWdcbiAgICovXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDEyICovXG4gIGNvbnN0cnVjdG9yKGVkaXQsIGNvdW50LCBjaGlsZHJlbiwgY29uZmlnKSB7XG4gICAgdGhpcy5lZGl0ID0gZWRpdFxuICAgIHRoaXMuY291bnQgPSBjb3VudFxuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnXG4gIH1cbiAgZ2V0IG5vZGVBcml0eSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHswfSAqLyAoMClcbiAgfVxuICBnZXQgZGF0YUFyaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50XG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFhcbiAgICogQHBhcmFtIHtBUEkuVWludDMyfSBfc2hpZnRcbiAgICogQHBhcmFtIHt1bmtub3dufSBfcGF0aFxuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKiBAcGFyYW0ge1h9IG5vdEZvdW5kXG4gICAqIEByZXR1cm5zIHtUfFh9XG4gICAqL1xuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGxvb2t1cChfc2hpZnQsIF9wYXRoLCBrZXksIG5vdEZvdW5kKSB7XG4gICAgcmV0dXJuIGxvb2t1cENvbGxpc2lvbih0aGlzLCBrZXksIG5vdEZvdW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBSXG4gICAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICAgKiBAcGFyYW0ge0FQSS5VaW50MzJ9IF9zaGlmdFxuICAgKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snUGF0aCddWydmcm9tJ10+fSBwYXRoXG4gICAqIEBwYXJhbSB7S3xSfSBrZXlcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gYWRkZWRMZWFmXG4gICAqIEByZXR1cm5zIHtBUEkuSGFzaENvbGxpc2lvbk5vZGU8VCwgSyB8IFIsIEM+fVxuICAgKi9cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBhc3NvY2lhdGUoZWRpdCwgX3NoaWZ0LCBwYXRoLCBrZXksIHZhbHVlLCBhZGRlZExlYWYpIHtcbiAgICByZXR1cm4gYXNzb2NpYXRlQ29sbGlzaW9uKHRoaXMsIGVkaXQsIHBhdGgsIGtleSwgdmFsdWUsIGFkZGVkTGVhZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAgICogQHBhcmFtIHtBUEkuVWludDMyfSBfc2hpZnRcbiAgICogQHBhcmFtIHtSZXR1cm5UeXBlPENbJ1BhdGgnXVsnZnJvbSddPn0gcGF0aFxuICAgKiBAcGFyYW0ge0t9IGtleVxuICAgKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gcmVtb3ZlZExlYWZcbiAgICogQHJldHVybnMge0FQSS5Ob2RlPFQsIEssIEM+fVxuICAgKi9cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBkaXNzb2NpYXRlKGVkaXQsIF9zaGlmdCwgcGF0aCwga2V5LCByZW1vdmVkTGVhZikge1xuICAgIHJldHVybiBkaXNzb2NpYXRlQ29sbGlzaW9uKHRoaXMsIGVkaXQsIHBhdGgsIGtleSwgcmVtb3ZlZExlYWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmb3JrKGVkaXQgPSBudWxsKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7dGhpc30gKi8gKGZvcmtDb2xsaXNpb24odGhpcywgZWRpdCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8W0ssIFRdPn1cbiAgICovXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcyh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPEs+fVxuICAgKi9cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiBrZXlzKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gdmFsdWVzKHRoaXMpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHRlbXBsYXRlIFhcbiAqIEBwYXJhbSB7QVBJLkhhc2hDb2xsaXNpb25Ob2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEBwYXJhbSB7WH0gbm90Rm91bmRcbiAqIEByZXR1cm5zIHtUfFh9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDggKi9cbmV4cG9ydCBjb25zdCBsb29rdXBDb2xsaXNpb24gPSAobm9kZSwgbmFtZSwgbm90Rm91bmQpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbjogZW50cmllcywgY291bnQgfSA9IG5vZGVcbiAgLy8gZmluZCB3aGVyZSBlbnRyeSB3aXRoIHRoaXMgbmFtZSBiZWxvbmdzXG4gIGNvbnN0IG4gPSBmaW5kSGFzaENvbGxpc2lvbk5vZGVJbmRleChlbnRyaWVzLCBjb3VudCwgbmFtZSlcbiAgLy8gaWYgZW50cnkgbmFtZSBhdCB0aGlzIGluZGV4IG1hdGNoZXMgZ2l2ZW4gbmFtZSByZXR1cm4gdGhlIHZhbHVlIG90aGVyd2lzZVxuICAvLyByZXR1cm4gYG5vdEZvdW5kYCBhcyB3ZSBoYXZlIG5vIHN1Y2ggZW50cnkuXG4gIHJldHVybiBlbnRyaWVzW25dID09PSBuYW1lID8gLyoqIEB0eXBlIHtUfSAqLyAoZW50cmllc1tuICsgMV0pIDogbm90Rm91bmRcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHRlbXBsYXRlIHtzdHJpbmd9IFJcbiAqIEBwYXJhbSB7QVBJLkhhc2hDb2xsaXNpb25Ob2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAqIEBwYXJhbSB7UmV0dXJuVHlwZTxDWydQYXRoJ11bJ2Zyb20nXT59IGtleVxuICogQHBhcmFtIHtLfFJ9IG5hbWVcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7e3ZhbHVlOmJvb2xlYW59fSBhZGRlZExlYWZcbiAqIEByZXR1cm5zIHtBUEkuSGFzaENvbGxpc2lvbk5vZGU8VCwgSyB8IFIsIEM+fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyNiAqL1xuZXhwb3J0IGNvbnN0IGFzc29jaWF0ZUNvbGxpc2lvbiA9IChub2RlLCBlZGl0LCBrZXksIG5hbWUsIHZhbHVlLCBhZGRlZExlYWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY291bnQgfSA9IG5vZGVcblxuICBjb25zdCBpbmRleCA9IGZpbmRIYXNoQ29sbGlzaW9uTm9kZUluZGV4KGNoaWxkcmVuLCBjb3VudCwgbmFtZSlcbiAgLy8gSWYgZW50cnkgYXQgdGhpcyBpbmRleCBoYXMgYSBkaWZmZXJlbnQgbmFtZSB3ZSBmb3JrIHRoZSBub2RlIGFuZFxuICAvLyBhZGQgYSBuZXcgZW50cnkuXG4gIGlmIChjaGlsZHJlbltpbmRleF0gIT09IG5hbWUpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZS5mb3JrKGVkaXQpXG4gICAgYWRkZWRMZWFmLnZhbHVlID0gdHJ1ZVxuICAgIG5ld05vZGUuY291bnQgKz0gMVxuICAgIG5ld05vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCBrZXksIHZhbHVlKVxuICAgIHJldHVybiBuZXdOb2RlXG4gIH1cbiAgLy8gSWYgbmFtZSBpcyB0aGUgc2FtZSBidXQgdmFsdWUgaXMgbm90IHdlIGZvcmsgdGhlIG5vZGUgYW5kIHVwZGF0ZVxuICAvLyB0aGUgdmFsdWVcbiAgZWxzZSBpZiAoY2hpbGRyZW5baW5kZXggKyAxXSAhPT0gdmFsdWUpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZS5mb3JrKGVkaXQpXG4gICAgbmV3Tm9kZS5jaGlsZHJlbltpbmRleCArIDFdID0gdmFsdWVcbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9XG4gIC8vIElmIHdlIGdvdCB0aGlzIGZhciBlbnRyeSB3aXRoIHRoaXMgZXhhY3QgbmFtZSBhbmQgdmFsdWUgaXMgYWxyZWFkeVxuICAvLyBwcmVzZW50IG1ha2luZyB0aGlzIGEgbm9vcCwgc28gd2UgcmV0dXJuIHRoaXMgbm9kZSBiYWNrLlxuICBlbHNlIHtcbiAgICByZXR1cm4gbm9kZVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IENcbiAqIEBwYXJhbSB7QVBJLkhhc2hDb2xsaXNpb25Ob2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAqIEBwYXJhbSB7UmV0dXJuVHlwZTxDWydQYXRoJ11bJ2Zyb20nXT59IGhhc2hcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHBhcmFtIHt7dmFsdWU6Ym9vbGVhbn19IHJlbW92ZWRMZWFmXG4gKiBAcmV0dXJucyB7QVBJLk5vZGU8VCwgSywgQz59XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDM3ICovXG5leHBvcnQgY29uc3QgZGlzc29jaWF0ZUNvbGxpc2lvbiA9IChub2RlLCBlZGl0LCBoYXNoLCBuYW1lLCByZW1vdmVkTGVhZikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuOiBlbnRyaWVzLCBjb3VudCwgY29uZmlnIH0gPSBub2RlXG4gIGNvbnN0IGluZGV4ID0gZmluZEhhc2hDb2xsaXNpb25Ob2RlSW5kZXgoZW50cmllcywgY291bnQsIG5hbWUpXG4gIC8vIElmIHRoZXJlIGlzIG5vIGVudHJ5IHdpdGggYSB0aGUgZ2l2ZW4gbmFtZSB0aGlzIGlzIG5vb3Agc28gd2UganVzdFxuICAvLyByZXR1cm4gYmFjayB0aGlzIG5vZGUuXG4gIGlmIChlbnRyaWVzW2luZGV4XSAhPT0gbmFtZSkge1xuICAgIHJldHVybiBub2RlXG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlZExlYWYudmFsdWUgPSB0cnVlXG4gICAgLy8gSWYgY29uZmxpY3QgY29udGFpbmVkIG9ubHkgdHdvIGVudHJpZXMgcmVtb3Zpbmcgb25lIG9mIHRoZW0gd291bGRcbiAgICAvLyBsZWF2ZSB1cyB3aXRoIG5vIGNvbmZsaWN0IHdoaWNoIGlzIHdoeSB3ZSBjcmVhdGUgYSBuZXcgbm9kZSB3aXRoIGFcbiAgICAvLyBhbiBlbnRyeSBvdGhlciB0aGFuIG9uZSB0aGF0IHdvdWxkIGNvcnJlc3BvbmQgcHJvdmlkZWQgbmFtZVxuICAgIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggPT09IDAgPyAyIDogMFxuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fSAqLyAoXG4gICAgICAgIGFzc29jaWF0ZShcbiAgICAgICAgICBjcmVhdGUoY29uZmlnKSxcbiAgICAgICAgICBlZGl0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgaGFzaCxcbiAgICAgICAgICAvKiogQHR5cGUge0t9ICovIChlbnRyaWVzW29mZnNldF0pLFxuICAgICAgICAgIC8qKiBAdHlwZSB7VH0gKi8gKGVudHJpZXNbb2Zmc2V0ICsgMV0pLFxuICAgICAgICAgIHJlbW92ZWRMZWFmXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHdlIGdvdCB0aGlzIGZhciB3ZSBoYXZlIG1vcmUgdGhhbiB0d28gY29sbGlkaW5nIGVudHJpZXMgaW5cbiAgICAvLyB3aGljaCBjYXNlIHdlIHNpbXBseSByZW1vdmUgb25lIGNvcnJlc3BvbmRpbmcgdG8gZ2l2ZW4gYG5hbWVgLlxuICAgIC8vXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuZXdOb2RlID0gbm9kZS5mb3JrKGVkaXQpXG4gICAgICBuZXdOb2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMilcbiAgICAgIG5ld05vZGUuY291bnQgLT0gMVxuICAgICAgcmV0dXJuIG5ld05vZGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuSGFzaENvbGxpc2lvbk5vZGU8VCwgSywgQz59IG5vZGVcbiAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICogQHJldHVybnMge0FQSS5IYXNoQ29sbGlzaW9uTm9kZTxULCBLLCBDPn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMTIgKi9cbmV4cG9ydCBjb25zdCBmb3JrQ29sbGlzaW9uID0gKG5vZGUsIGVkaXQgPSBudWxsKSA9PiB7XG4gIGlmIChjYW5FZGl0KG5vZGUuZWRpdCwgZWRpdCkpIHtcbiAgICByZXR1cm4gbm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUoXG4gICAgICBlZGl0LFxuICAgICAgbm9kZS5jb3VudCxcbiAgICAgIC8qKiBAdHlwZSB7QVBJLkNvbGxpc2lvbkVudHJpZXM8VCwgSz59ICovIChub2RlLmNoaWxkcmVuLnNsaWNlKCkpLFxuICAgICAgbm9kZS5jb25maWdcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggaW5zaWRlIGNvbGxpc2lvbiBlbnRyaWVzIHdoZXJlIGdpdmVuIGBrZXlgIGJlbG9uZ3MsIHdoaWNoIGlzXG4gKiBpbmRleCB3aGVyZSBga2V5IDw9IGVudHJpZXNbaW5kZXhdYCBpcyBgdHJ1ZWAuIElmIG5vIGluZGV4IHNhdGlzZmllcyB0aGlzXG4gKiBjb25zdHJhaW50IGluZGV4IHdpbGwgYmUgYGVudHJpZXMubGVuZ3RoYCBpbmRpY2F0aW5nIHRoYXQga2V5IGJlbG9uZ3MgaW4gdGhlXG4gKiBsYXN0IHBvc2l0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHBhcmFtIHtBUEkuQ29sbGlzaW9uRW50cmllczxULCBLPn0gZW50cmllc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0t9IGtleVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCA4ICovXG5jb25zdCBmaW5kSGFzaENvbGxpc2lvbk5vZGVJbmRleCA9IChlbnRyaWVzLCBjb3VudCwga2V5KSA9PiB7XG4gIGxldCBpbmRleCA9IDBcbiAgLy8gaW5jcmVhc2UgaW5kZXggdW50aWwgd2UgZmluZCBhIGluZGV4IHdoZXJlIGtleSA8PSBlbnRyaWVzW2luZGV4XVxuICB3aGlsZSAoaW5kZXggPCBjb3VudCAmJiBlbnRyaWVzW2luZGV4XSA+IGtleSkge1xuICAgIGluZGV4ICs9IDJcbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cblxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHsgYml0V2lkdGg6IDMyLCBCaXRGaWVsZCwgUGF0aCB9XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IFtlZGl0XVxuICogQHBhcmFtIHtDfSBjb25maWdcbiAqIEByZXR1cm5zIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoY29uZmlnLCBlZGl0ID0gbnVsbCkgPT5cbiAgbmV3IEJpdG1hcEluZGV4ZWROb2RlKFxuICAgIGVkaXQsXG4gICAgY29uZmlnLkJpdEZpZWxkLmVtcHR5KE1hdGgucG93KDIsIGNvbmZpZy5iaXRXaWR0aCkpLFxuICAgIGNvbmZpZy5CaXRGaWVsZC5lbXB0eShNYXRoLnBvdygyLCBjb25maWcuYml0V2lkdGgpKSxcbiAgICAvKiogQHR5cGUge0FQSS5DaGlsZHJlbjxULCBLLCBDPn0gKi8gKFtdKSxcbiAgICBjb25maWdcbiAgKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULCBVXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSz59IG5vZGVcbiAqIEBwYXJhbSB7S30ga2V5XG4gKiBAcGFyYW0ge1V9IG5vdEZvdW5kXG4gKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAobm9kZSwga2V5LCBub3RGb3VuZCkgPT5cbiAgbG9va3VwKG5vZGUsIDAsIG5vZGUuY29uZmlnLlBhdGguZnJvbShrZXkpLCBrZXksIG5vdEZvdW5kKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULCBVXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIEJpdHMsIEJpdE1hcFxuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQVBJLkNvbmZpZzxCaXRzLCBCaXRNYXA+Pn0gbm9kZVxuICogQHBhcmFtIHtBUEkuVWludDMyfSBkZXB0aFxuICogQHBhcmFtIHtCaXRzfSBwYXRoXG4gKiBAcGFyYW0ge0t9IGtleVxuICogQHBhcmFtIHtVfSBub3RGb3VuZFxuICogQHJldHVybnMge1R8VX1cbiAqL1xuZXhwb3J0IGNvbnN0IGxvb2t1cCA9IChub2RlLCBkZXB0aCwgcGF0aCwga2V5LCBub3RGb3VuZCkgPT4ge1xuICBjb25zdCB7IGRhdGFtYXAsIG5vZGVtYXAsIGNvbmZpZyB9ID0gbm9kZVxuICBjb25zdCB7IFBhdGgsIEJpdEZpZWxkIH0gPSBjb25maWdcbiAgY29uc3Qgb2Zmc2V0ID0gUGF0aC5hdChwYXRoLCBkZXB0aClcblxuICAvLyBJZiBiaXQgaXMgc2V0IGluIHRoZSBkYXRhIGJpdG1hcCB3ZSBoYXZlIHNvbWUga2V5LCB2YWx1ZSB1bmRlciB0aGVcbiAgLy8gbWF0Y2hpbmcgaGFzaCBzZWdtZW50LlxuICBpZiAoQml0RmllbGQuZ2V0KGRhdGFtYXAsIG9mZnNldCkpIHtcbiAgICBjb25zdCBpbmRleCA9IEJpdEZpZWxkLnBvcGNvdW50KGRhdGFtYXAsIG9mZnNldClcbiAgICAvLyBJZiBrZXkgbWF0Y2hlcyBhY3R1YWwga2V5IGluIHRoZSBtYXAgd2UgZm91bmQgdGhlIHRoZSB2YWx1ZVxuICAgIC8vIG90aGVyd2lzZSB3ZSBkaWQgbm90LlxuICAgIGlmIChrZXlBdChub2RlLCBpbmRleCkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlQXQobm9kZSwgaW5kZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub3RGb3VuZFxuICAgIH1cbiAgfVxuICAvLyBJZiBiaXQgaXMgc2V0IGluIHRoZSBub2RlIGJpdG1hcHQgd2UgaGF2ZSBhIG5vZGUgdW5kZXIgdGhlXG4gIC8vIG1hdGNoaW5nIGhhc2ggc2VnbWVudC5cbiAgZWxzZSBpZiAoQml0RmllbGQuZ2V0KG5vZGVtYXAsIG9mZnNldCkpIHtcbiAgICAvLyBSZXNvbHZlIG5vZGUgYW5kIGNvbnRpbnVlIGxvb2t1cCB3aXRoaW4gaXQuXG4gICAgY29uc3QgY2hpbGQgPSByZXNvbHZlTm9kZShub2RlLCBvZmZzZXQpXG4gICAgcmV0dXJuIGNoaWxkLmxvb2t1cChkZXB0aCArIDEsIHBhdGgsIGtleSwgbm90Rm91bmQpXG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSBuZWl0aGVyIG5vZGUgbm9yIGtleS1wYWlyIGZvciB0aGlzIGhhc2ggc2VnbWVudFxuICAvLyB3ZSByZXR1cm4gbm90Rm91bmQuXG4gIGVsc2Uge1xuICAgIHJldHVybiBub3RGb3VuZFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIFVcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcGFyYW0ge1J9IGtleVxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHt7IHZhbHVlOiBib29sZWFuIH19IGFkZGVkTGVhZlxuICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLfFIsIEM+fVxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gKG5vZGUsIGVkaXQsIGtleSwgdmFsdWUsIGFkZGVkTGVhZikgPT5cbiAgYXNzb2NpYXRlKG5vZGUsIGVkaXQsIDAsIG5vZGUuY29uZmlnLlBhdGguZnJvbShrZXkpLCBrZXksIHZhbHVlLCBhZGRlZExlYWYpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gUlxuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcGFyYW0ge0FQSS5VaW50MzJ9IGRlcHRoXG4gKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snUGF0aCddWydmcm9tJ10+fSBwYXRoXG4gKiBAcGFyYW0ge0t8Un0ga2V5XG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gYWRkZWRMZWFmXG4gKiBAcmV0dXJucyB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEsgfCBSLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc29jaWF0ZSA9IChub2RlLCBlZGl0LCBkZXB0aCwgcGF0aCwga2V5LCB2YWx1ZSwgYWRkZWRMZWFmKSA9PiB7XG4gIGNvbnN0IHsgZGF0YW1hcCwgbm9kZW1hcCwgY29uZmlnIH0gPSBub2RlXG4gIGNvbnN0IHsgUGF0aCwgQml0RmllbGQgfSA9IGNvbmZpZ1xuICBjb25zdCBvZmZzZXQgPSBQYXRoLmF0KHBhdGgsIGRlcHRoKVxuICAvLyBJZiBiaXQgaXMgc2V0IGluIHRoZSBkYXRhIGJpdG1hcCB3ZSBoYXZlIHNvbWUga2V5LCB2YWx1ZSB1bmRlciB0aGVcbiAgLy8gbWF0Y2hpbmcgaGFzaCBzZWdtZW50LlxuICBpZiAoQml0RmllbGQuZ2V0KGRhdGFtYXAsIG9mZnNldCkpIHtcbiAgICBjb25zdCBpbmRleCA9IEJpdEZpZWxkLnBvcGNvdW50KGRhdGFtYXAsIG9mZnNldClcbiAgICBjb25zdCBmb3VuZCA9IGtleUF0KG5vZGUsIGluZGV4KVxuICAgIC8vIElmIHdlIGhhdmUgZW50cnkgd2l0aCBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBpcyB0aGUgc2FtZSByZXR1cm4gbm9kZVxuICAgIC8vIGFzIGlzLCBvdGhlcndpc2UgZm9yayBub2RlIGFuZCBzZXQgdGhlIHZhbHVlLlxuICAgIGlmIChrZXkgPT09IGZvdW5kKSB7XG4gICAgICByZXR1cm4gdmFsdWVBdChub2RlLCBpbmRleCkgPT09IHZhbHVlXG4gICAgICAgID8gbm9kZVxuICAgICAgICA6IGZvcmtBbmRTZXQobm9kZSwgZWRpdCwgaW5kZXgsIHZhbHVlKVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjcmVhdGUgYSBicmFuY2ggdG8gY29udGFpbiBjdXJyZW50IGtleSwgdmFsdWUgYW5kXG4gICAgLy8gb25lIGJlZW4gcGFzc2VkLlxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYnJhbmNoID0gbWVyZ2VUd29MZWF2ZXMoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZWRpdCxcbiAgICAgICAgZGVwdGggKyAxLFxuICAgICAgICBQYXRoLmZyb20oZm91bmQpLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgdmFsdWVBdChub2RlLCBpbmRleCksXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIClcbiAgICAgIGFkZGVkTGVhZi52YWx1ZSA9IHRydWVcblxuICAgICAgcmV0dXJuIG1pZ3JhdGVMZWFmVG9CcmFuY2gobm9kZSwgZWRpdCwgb2Zmc2V0LCBicmFuY2gpXG4gICAgfVxuICB9XG4gIC8vIElmIGJpdCBpcyBzZXQgaW4gdGhlIG5vZGUgYml0bWFwIHdlIGhhdmUgYSBicmFuY2ggdW5kZXIgdGhlIGN1cnJlbnRcbiAgLy8gaGFzaCBzbGljZS5cbiAgZWxzZSBpZiAoQml0RmllbGQuZ2V0KG5vZGVtYXAsIG9mZnNldCkpIHtcbiAgICBjb25zdCBjaGlsZCA9IHJlc29sdmVOb2RlKG5vZGUsIG9mZnNldClcbiAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLmFzc29jaWF0ZShcbiAgICAgIGVkaXQsXG4gICAgICBkZXB0aCArIDEsXG4gICAgICBwYXRoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBhZGRlZExlYWZcbiAgICApXG5cbiAgICBpZiAoY2hpbGQgPT09IG5ld0NoaWxkKSB7XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29weUFuZFNldENoaWxkKG5vZGUsIGVkaXQsIG9mZnNldCwgbmV3Q2hpbGQpXG4gICAgfVxuICB9XG4gIC8vIElmIHdlIGhhdmUgbmVpdGhlciBub2RlIG5vciBhIGtleS12YWx1ZSBmb3IgdGhpcyBoYXNoIHNlZ21lbnQuIFdlIGNvcHlcbiAgLy8gY3VycmVudCBjaGlsZHJlbiBhbmQgYWRkIG5ldyBrZXktdmFsdWUgcGFpclxuICBlbHNlIHtcbiAgICBjb25zdCBpbmRleCA9IEJpdEZpZWxkLnBvcGNvdW50KGRhdGFtYXAsIG9mZnNldClcbiAgICBhZGRlZExlYWYudmFsdWUgPSB0cnVlXG5cbiAgICAvKiogQHR5cGUge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLfFIsIEM+fSAqL1xuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlLmZvcmsoZWRpdClcblxuICAgIC8vIENhcHR1cmUgbmV3IGVudHJ5IGluIHRoZSBkYXRhIGJpdG1hcFxuICAgIG5ld05vZGUuZGF0YW1hcCA9IEJpdEZpZWxkLnNldChkYXRhbWFwLCBvZmZzZXQpXG4gICAgbmV3Tm9kZS5jaGlsZHJlbi5zcGxpY2Uoa2V5UG9zaXRpb24oaW5kZXgpLCAwLCBrZXksIHZhbHVlKVxuICAgIHJldHVybiBuZXdOb2RlXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59IG5vZGVcbiAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7eyB2YWx1ZTogYm9vbGVhbiB9fSByZW1vdmVkTGVhZlxuICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn1cbiAqL1xuY29uc3QgcmVtb3ZlID0gKG5vZGUsIGVkaXQsIGtleSwgcmVtb3ZlZExlYWYpID0+XG4gIGRpc3NvY2lhdGUobm9kZSwgZWRpdCwgMCwgbm9kZS5jb25maWcuUGF0aC5mcm9tKGtleSksIGtleSwgcmVtb3ZlZExlYWYpXG5cbmV4cG9ydCB7IHJlbW92ZSBhcyBkZWxldGUgfVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gc291cmNlXG4gKiBAcGFyYW0ge0FQSS5FZGl0fG51bGx9IGVkaXRcbiAqIEBwYXJhbSB7QVBJLlVpbnQzMn0gZGVwdGhcbiAqIEBwYXJhbSB7UmV0dXJuVHlwZTxDWydQYXRoJ11bJ2Zyb20nXT59IHBhdGhcbiAqIEBwYXJhbSB7S30ga2V5XG4gKiBAcGFyYW0ge3t2YWx1ZTpib29sZWFufX0gcmVtb3ZlZExlYWZcbiAqIEByZXR1cm5zIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gKi9cbmV4cG9ydCBjb25zdCBkaXNzb2NpYXRlID0gKHNvdXJjZSwgZWRpdCwgZGVwdGgsIHBhdGgsIGtleSwgcmVtb3ZlZExlYWYpID0+IHtcbiAgY29uc3QgeyBkYXRhbWFwLCBub2RlbWFwLCBjb25maWcgfSA9IHNvdXJjZVxuICBjb25zdCB7IEJpdEZpZWxkLCBQYXRoIH0gPSBjb25maWdcbiAgY29uc3Qgb2Zmc2V0ID0gUGF0aC5hdChwYXRoLCBkZXB0aClcbiAgLy8gSWYgYml0IGlzIHNldCBpbiB0aGUgZGF0YSBiaXRtYXAgd2UgaGF2ZSBhbiBlbnRyeSB1bmRlciB0aGVcbiAgLy8gbWF0Y2hpbmcgaGFzaCBzZWdtZW50LlxuICBpZiAoQml0RmllbGQuZ2V0KGRhdGFtYXAsIG9mZnNldCkpIHtcbiAgICBjb25zdCBpbmRleCA9IEJpdEZpZWxkLnBvcGNvdW50KGRhdGFtYXAsIG9mZnNldClcbiAgICAvLyBJZiBrZXkgYXQgYSBnaXZlbiBpbmRleCBtYXRjaGVzIGdpdmVuIGBuYW1lYCB3ZSBmb3JrIGEgbm9kZSBhbmQgcmVtb3ZlXG4gICAgLy8gdGhlIGVudHJ5XG4gICAgaWYgKGtleSA9PT0ga2V5QXQoc291cmNlLCBpbmRleCkpIHtcbiAgICAgIHJlbW92ZWRMZWFmLnZhbHVlID0gdHJ1ZVxuICAgICAgY29uc3Qgbm9kZSA9IGZvcmsoc291cmNlLCBlZGl0KVxuICAgICAgLy8gVXBkYXRlIHRoZSBiaXRtYXBcbiAgICAgIG5vZGUuZGF0YW1hcCA9IEJpdEZpZWxkLnVuc2V0KHNvdXJjZS5kYXRhbWFwLCBvZmZzZXQpXG4gICAgICAvLyByZW1vdmUgdGhlIGNoaWxkXG4gICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShrZXlQb3NpdGlvbihpbmRleCksIDIpXG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2Ugd2UgZG9uJ3QgaGF2ZSBzdWNoIGVudHJ5IHNvIHdlIHJldHVybiBub2RlIGJhY2sgYXMgaXMuXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfVxuICB9XG4gIC8vIElmIGJpdCBpcyBzZXQgaW4gdGhlIG5vZGUgYml0bWFwdCB3ZSBoYXZlIGEgbm9kZSB1bmRlciB0aGVcbiAgLy8gbWF0Y2hpbmcgaGFzaCBzZWdtZW50LlxuICBlbHNlIGlmIChCaXRGaWVsZC5nZXQobm9kZW1hcCwgb2Zmc2V0KSkge1xuICAgIGNvbnN0IG5vZGUgPSByZXNvbHZlTm9kZShzb3VyY2UsIG9mZnNldClcbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuZGlzc29jaWF0ZShlZGl0LCBkZXB0aCArIDEsIHBhdGgsIGtleSwgcmVtb3ZlZExlYWYpXG4gICAgLy8gaWYgY2hpbGQgaGFzIGEgc2luZ2xlIGVsZW1lbnQgd2UgbmVlZCB0byBjYW5vbmljYWxpemVcbiAgICBpZiAoaGFzU2luZ2xlTGVhZihjaGlsZCkpIHtcbiAgICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBzaW5nbGUgY2hpbGQsIHdlIGNvbGxhcHNlIGFuZCByZXR1cm4gdGhlIGNoaWxkXG4gICAgICAvLyBvdGhlcndpc2Ugd2UgaW5saW5lIHRoZSBjaGlsZC5cbiAgICAgIHJldHVybiBoYXNTaW5nbGVOb2RlKHNvdXJjZSlcbiAgICAgICAgPyBjaGlsZFxuICAgICAgICA6IGlubGluZUNoaWxkKHNvdXJjZSwgZWRpdCwgb2Zmc2V0LCBjaGlsZClcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGNoaWxkKSB7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb3B5QW5kU2V0Q2hpbGQoc291cmNlLCBlZGl0LCBvZmZzZXQsIGNoaWxkKVxuICAgIH1cbiAgfVxuICAvLyBJZiB3ZSBoYXZlIG5laXRoZXIgbm9kZSBub3IgYSBrZXktdmFsdWUgZm9yIHRoaXMgaGFzaCBzZWdtZW50IHRoaXMgaXMgYVxuICAvLyBub29wLlxuICBlbHNlIHtcbiAgICByZXR1cm4gc291cmNlXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8W0ssIFRdPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVudHJpZXMgPSBmdW5jdGlvbiogKHsgY2hpbGRyZW4gfSkge1xuICBsZXQgb2Zmc2V0ID0gMFxuICBjb25zdCBjb3VudCA9IGNoaWxkcmVuLmxlbmd0aFxuICB3aGlsZSAob2Zmc2V0IDwgY291bnQpIHtcbiAgICBjb25zdCBrZXkgPSBjaGlsZHJlbltvZmZzZXRdXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9mZnNldCArPSAxXG4gICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkcmVuW29mZnNldF1cbiAgICAgIHlpZWxkIC8qKiBAdHlwZSB7W0ssIFRdfSAqLyAoW2tleSwgdmFsdWVdKVxuICAgICAgb2Zmc2V0ICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAob2Zmc2V0IDwgY291bnQpIHtcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59ICovIChcbiAgICAgIGNoaWxkcmVuW29mZnNldF1cbiAgICApXG4gICAgeWllbGQqIG5vZGUuZW50cmllcygpXG4gICAgb2Zmc2V0ICs9IDFcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcmV0dXJucyB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fVxuICovXG5leHBvcnQgY29uc3QgZm9yayA9IChub2RlLCBlZGl0KSA9PiB7XG4gIGlmIChjYW5FZGl0KG5vZGUuZWRpdCwgZWRpdCkpIHtcbiAgICByZXR1cm4gbm9kZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgQml0bWFwSW5kZXhlZE5vZGUoXG4gICAgICBlZGl0LFxuICAgICAgbm9kZS5kYXRhbWFwLFxuICAgICAgbm9kZS5ub2RlbWFwLFxuICAgICAgbm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgICAgbm9kZS5jb25maWdcbiAgICApXG4gICAgcmV0dXJuIG5ld05vZGVcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5Ob2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxLPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGtleXMgPSBmdW5jdGlvbiogKHsgY2hpbGRyZW4gfSkge1xuICBsZXQgb2Zmc2V0ID0gMFxuICBjb25zdCBjb3VudCA9IGNoaWxkcmVuLmxlbmd0aFxuICB3aGlsZSAob2Zmc2V0IDwgY291bnQpIHtcbiAgICBjb25zdCBrZXkgPSBjaGlsZHJlbltvZmZzZXRdXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHlpZWxkIC8qKiBAdHlwZSB7S30gKi8gKGtleSlcbiAgICAgIG9mZnNldCArPSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IGNvdW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEs+fSAqLyAoY2hpbGRyZW5bb2Zmc2V0XSlcbiAgICB5aWVsZCogbm9kZS5rZXlzKClcbiAgICBvZmZzZXQgKz0gMVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IENcbiAqIEBwYXJhbSB7QVBJLk5vZGU8VCwgSywgQz59IG5vZGVcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgY29uc3QgdmFsdWVzID0gZnVuY3Rpb24qICh7IGNoaWxkcmVuIH0pIHtcbiAgbGV0IG9mZnNldCA9IDBcbiAgY29uc3QgY291bnQgPSBjaGlsZHJlbi5sZW5ndGhcbiAgd2hpbGUgKG9mZnNldCA8IGNvdW50KSB7XG4gICAgY29uc3Qga2V5ID0gY2hpbGRyZW5bb2Zmc2V0XVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvZmZzZXQgKz0gMVxuICAgICAgeWllbGQgLyoqIEB0eXBlIHtUfSAqLyAoY2hpbGRyZW5bb2Zmc2V0XSlcbiAgICAgIG9mZnNldCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IGNvdW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEs+fSAqLyAoY2hpbGRyZW5bb2Zmc2V0XSlcbiAgICB5aWVsZCogbm9kZS52YWx1ZXMoKVxuICAgIG9mZnNldCArPSAxXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59IG5vZGVcbiAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZm9ya0FuZFNldCA9IChub2RlLCBlZGl0LCBvZmZzZXQsIHZhbHVlKSA9PiB7XG4gIGNvbnN0IG5ld05vZGUgPSBub2RlLmZvcmsoZWRpdClcbiAgbmV3Tm9kZS5jaGlsZHJlblt2YWx1ZVBvc2l0aW9uKG9mZnNldCldID0gdmFsdWVcbiAgcmV0dXJuIG5ld05vZGVcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59IHNvdXJjZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge0FQSS5Ob2RlPFQsIEssIEM+fSBjaGlsZFxuICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlubGluZUNoaWxkID0gKHNvdXJjZSwgZWRpdCwgb2Zmc2V0LCBjaGlsZCkgPT4ge1xuICBjb25zdCB7IGRhdGFtYXAsIG5vZGVtYXAsIGNvbmZpZyB9ID0gc291cmNlXG4gIGNvbnN0IHsgQml0RmllbGQgfSA9IGNvbmZpZ1xuICBjb25zdCBub2RlID0gZm9yayhzb3VyY2UsIGVkaXQpXG5cbiAgLy8gcmVtb3ZlIHRoZSBub2RlIHRoYXQgd2UgYXJlIGlubGluaW5nXG4gIG5vZGUuY2hpbGRyZW4uc3BsaWNlKG5vZGVQb3NpdGlvbihzb3VyY2UsIG9mZnNldCksIDEpXG4gIC8vIGFkZCBrZXktdmFsdWUgcGFpciB3aGVyZSBpdCB3b2x1ZCBmYWxsXG4gIG5vZGUuY2hpbGRyZW4uc3BsaWNlKFxuICAgIGtleVBvc2l0aW9uKEJpdEZpZWxkLnBvcGNvdW50KGRhdGFtYXAsIG9mZnNldCkpLFxuICAgIDAsXG4gICAgY2hpbGQuY2hpbGRyZW5bMF0sXG4gICAgY2hpbGQuY2hpbGRyZW5bMV1cbiAgKVxuXG4gIG5vZGUuZGF0YW1hcCA9IEJpdEZpZWxkLnNldChkYXRhbWFwLCBvZmZzZXQpXG4gIG5vZGUubm9kZW1hcCA9IEJpdEZpZWxkLnVuc2V0KG5vZGVtYXAsIG9mZnNldClcblxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge0FQSS5Ob2RlPFQsIEssIEM+fSBjaGlsZFxuICogQHJldHVybnMge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlBbmRTZXRDaGlsZCA9IChub2RlLCBlZGl0LCBvZmZzZXQsIGNoaWxkKSA9PiB7XG4gIGNvbnN0IG5ld05vZGUgPSBmb3JrKG5vZGUsIGVkaXQpXG4gIG5ld05vZGUuY2hpbGRyZW5bbm9kZVBvc2l0aW9uKG5vZGUsIG9mZnNldCldID0gY2hpbGRcbiAgcmV0dXJuIG5ld05vZGVcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59IHNvdXJjZVxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge0FQSS5Ob2RlPFQsIEssIEM+fSBicmFuY2hcbiAqIEByZXR1cm5zIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gKi9cbmV4cG9ydCBjb25zdCBtaWdyYXRlTGVhZlRvQnJhbmNoID0gKHNvdXJjZSwgZWRpdCwgb2Zmc2V0LCBicmFuY2gpID0+IHtcbiAgY29uc3QgeyBub2RlbWFwLCBkYXRhbWFwLCBjb25maWcgfSA9IHNvdXJjZVxuICBjb25zdCB7IEJpdEZpZWxkIH0gPSBjb25maWdcbiAgY29uc3QgaW5kZXggPSBCaXRGaWVsZC5wb3Bjb3VudChkYXRhbWFwLCBvZmZzZXQpXG4gIC8vIFByZXZpb3VzIGlkIGNvcnJlc3BvbmRzIHRvIHRoZSBrZXkgcG9zaXRpb25cbiAgY29uc3Qgb2xkSWQgPSBrZXlQb3NpdGlvbihpbmRleClcbiAgY29uc3QgbmV3SWQgPSBub2RlUG9zaXRpb24oc291cmNlLCBvZmZzZXQpXG5cbiAgY29uc3Qgbm9kZSA9IGZvcmsoc291cmNlLCBlZGl0KVxuXG4gIC8vIHJlbW92ZSBhbiBvbGQgbGVhZlxuICBub2RlLmRhdGFtYXAgPSBCaXRGaWVsZC51bnNldChkYXRhbWFwLCBvZmZzZXQpXG4gIG5vZGUuY2hpbGRyZW4uc3BsaWNlKG9sZElkLCAyKVxuXG4gIC8vIGFkZCBhIG5ldyBicmFuY2hcbiAgbm9kZS5ub2RlbWFwID0gQml0RmllbGQuc2V0KG5vZGVtYXAsIG9mZnNldClcbiAgbm9kZS5jaGlsZHJlbi5zcGxpY2UobmV3SWQgLSAxLCAwLCBicmFuY2gpXG5cbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEB0ZW1wbGF0ZSB7QVBJLkNvbmZpZ30gQ1xuICogQHBhcmFtIHtDfSBjb25maWdcbiAqIEBwYXJhbSB7QVBJLkVkaXR8bnVsbH0gZWRpdFxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKiBAcGFyYW0ge1JldHVyblR5cGU8Q1snUGF0aCddWydmcm9tJ10+fSBvbGRQYXRoXG4gKiBAcGFyYW0ge0t9IG9sZEtleVxuICogQHBhcmFtIHtUfSBvbGRWYWx1ZVxuICogQHBhcmFtIHtSZXR1cm5UeXBlPENbJ1BhdGgnXVsnZnJvbSddPn0gbmV3UGF0aFxuICogQHBhcmFtIHtLfSBuZXdLZXlcbiAqIEBwYXJhbSB7VH0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtBUEkuTm9kZTxULCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlVHdvTGVhdmVzID0gKFxuICBjb25maWcsXG4gIGVkaXQsXG4gIGRlcHRoLFxuICBvbGRQYXRoLFxuICBvbGRLZXksXG4gIG9sZFZhbHVlLFxuICBuZXdQYXRoLFxuICBuZXdLZXksXG4gIG5ld1ZhbHVlXG4pID0+IHtcbiAgY29uc3QgeyBCaXRGaWVsZCwgUGF0aCB9ID0gY29uZmlnXG4gIC8vIElmIHdlIGhhdmUgcmVhY2hlZCBlbmQgb2YgdGhlIHBhdGggd2UgY2FuIG5vIGxvbmdlciBjcmVhdGUgYW5vdGhlclxuICAvLyBgQml0bWFwSW5kZXhlZE5vZGVgLCBpbnN0ZWFkIHdlIGNyZWF0ZSBhIG5vZGUgY29udGFpbmluZyAoaGFzaCkgY29sbGlkaW5nXG4gIC8vIGVudHJpZXNcbiAgLyogYzggaWdub3JlIG5leHQgNyAqL1xuICBpZiAoUGF0aC5zaXplIDwgZGVwdGgpIHtcbiAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKFxuICAgICAgZWRpdCxcbiAgICAgIDIsXG4gICAgICBbb2xkS2V5LCBvbGRWYWx1ZSwgbmV3S2V5LCBuZXdWYWx1ZV0sXG4gICAgICBjb25maWdcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb2xkT2Zmc2V0ID0gUGF0aC5hdChvbGRQYXRoLCBkZXB0aClcbiAgICBjb25zdCBuZXdPZmZzZXQgPSBQYXRoLmF0KG5ld1BhdGgsIGRlcHRoKVxuICAgIC8vIElmIG9mZnNldHMgc3RpbGwgbWF0Y2ggY3JlYXRlIGFub3RoZXIgaW50ZXJtZWRpZXJ5IG5vZGUgYW5kIG1lcmdlIHRoZXNlXG4gICAgLy8gdHdvIG5vZGVzIGF0IG5leHQgZGVwdGggbGV2ZWwuXG4gICAgaWYgKG9sZE9mZnNldCA9PT0gbmV3T2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKFxuICAgICAgICBlZGl0LFxuICAgICAgICBCaXRGaWVsZC5lbXB0eShNYXRoLnBvdygyLCBjb25maWcuYml0V2lkdGgpKSxcbiAgICAgICAgQml0RmllbGQuZnJvbShbb2xkT2Zmc2V0XSwgTWF0aC5wb3coMiwgY29uZmlnLmJpdFdpZHRoKSksXG4gICAgICAgIFtcbiAgICAgICAgICBtZXJnZVR3b0xlYXZlcyhcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGVkaXQsXG4gICAgICAgICAgICBkZXB0aCArIDEsXG4gICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgb2xkS2V5LFxuICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgbmV3S2V5LFxuICAgICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICApLFxuICAgICAgICBdLFxuICAgICAgICBjb25maWdcbiAgICAgIClcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIGNyZWF0ZSBuZXcgbm9kZSB3aXRoIGJvdGgga2V5LXZhbHVlIHBhaXJzIGFzIGl0J3MgY2hpbGRyZW5cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUoXG4gICAgICAgIGVkaXQsXG4gICAgICAgIEJpdEZpZWxkLmZyb20oW29sZE9mZnNldCwgbmV3T2Zmc2V0XSwgTWF0aC5wb3coMiwgY29uZmlnLmJpdFdpZHRoKSksXG4gICAgICAgIEJpdEZpZWxkLmVtcHR5KE1hdGgucG93KDIsIGNvbmZpZy5iaXRXaWR0aCkpLFxuICAgICAgICAvKiogQHR5cGUge0FQSS5DaGlsZHJlbjxULCBLLCBDPn0gKi9cbiAgICAgICAgKFxuICAgICAgICAgIC8vIFdlIGluc2VydCBjaGlsZCB3aXRoIGEgbG93ZXIgaW5kZXggZmlyc3Qgc28gdGhhdCB3ZSBjYW4gZGVyaXZlIGl0J3NcbiAgICAgICAgICAvLyBpbmRleCBvbiBhY2Nlc3MgdmlhIHBvcGNvdW50XG4gICAgICAgICAgb2xkT2Zmc2V0IDwgbmV3T2Zmc2V0XG4gICAgICAgICAgICA/IFtvbGRLZXksIG9sZFZhbHVlLCBuZXdLZXksIG5ld1ZhbHVlXVxuICAgICAgICAgICAgOiBbbmV3S2V5LCBuZXdWYWx1ZSwgb2xkS2V5LCBvbGRWYWx1ZV1cbiAgICAgICAgKSxcbiAgICAgICAgY29uZmlnXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IEtcbiAqIEBwYXJhbSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPHVua25vd24sIEs+fSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZXhwb3J0IGNvbnN0IGtleUF0ID0gKHsgY2hpbGRyZW4gfSwgaW5kZXgpID0+XG4gIC8qKiBAdHlwZSB7S30gKi8gKGNoaWxkcmVuW2tleVBvc2l0aW9uKGluZGV4KV0pXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCBrZXlQb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICogMlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxUPn0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCB2YWx1ZUF0ID0gKHsgY2hpbGRyZW4gfSwgaW5kZXgpID0+XG4gIC8qKiBAdHlwZSB7VH0gKi8gKGNoaWxkcmVuW3ZhbHVlUG9zaXRpb24oaW5kZXgpXSlcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbHVlUG9zaXRpb24gPSBpbmRleCA9PiBpbmRleCAqIDIgKyAxXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUge0FQSS5Db25maWd9IENcbiAqIEBwYXJhbSB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7QVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fEFQSS5IYXNoQ29sbGlzaW9uTm9kZTxULCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVOb2RlID0gKG5vZGUsIG9mZnNldCkgPT5cbiAgLyoqIEB0eXBlIHtBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz58QVBJLkhhc2hDb2xsaXNpb25Ob2RlPFQsIEssIEM+fSAqLyAoXG4gICAgbm9kZS5jaGlsZHJlbltub2RlUG9zaXRpb24obm9kZSwgb2Zmc2V0KV1cbiAgKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5jb25zdCBub2RlUG9zaXRpb24gPSAoeyBjaGlsZHJlbiwgbm9kZW1hcCwgY29uZmlnIH0sIG9mZnNldCkgPT5cbiAgY2hpbGRyZW4ubGVuZ3RoIC0gMSAtIGNvbmZpZy5CaXRGaWVsZC5wb3Bjb3VudChub2RlbWFwLCBvZmZzZXQpXG5cbi8qKlxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBvd25lclxuICogQHBhcmFtIHtBUEkuRWRpdHxudWxsfSBlZGl0b3JcbiAqL1xuY29uc3QgY2FuRWRpdCA9IChvd25lciwgZWRpdG9yKSA9PiBvd25lciAhPSBudWxsICYmIG93bmVyID09PSBlZGl0b3JcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBub2RlIGhhcyBhIHNpbmdsZSBlbnRyeS4gSXQgYWxzbyByZWZpbmVzIHR5cGUgdG9cbiAqIGBCaXRtYXBJbmRleGVkTm9kZWAgYmVjYXVzZSBgSGFzaENvbGxpc2lvbk5vZGVgIGlzIG5vcm1hbGl6ZWQgdG9cbiAqIGBCaXRtYXBJbmRleGVkTm9kZWAgd2hlbiBpdCBjb250YWlucyBvbmx5IGEgc2luZ2xlIGVudHJ5LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5Ob2RlPFQsIEssIEM+fSBub2RlXG4gKiBAcmV0dXJucyB7bm9kZSBpcyBBUEkuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59XG4gKi9cbmNvbnN0IGhhc1NpbmdsZUxlYWYgPSBub2RlID0+IG5vZGUubm9kZUFyaXR5ID09PSAwICYmIG5vZGUuZGF0YUFyaXR5ID09PSAxXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgbm9kZSBoYXMgYSBzaW5nbGUgY2hpbGRlIG5vZGUgYW5kIDAgY2hpbGQgbGVhdmVzLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtBUEkuQ29uZmlnfSBDXG4gKiBAcGFyYW0ge0FQSS5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gbm9kZVxuICogQHJldHVybnMge25vZGUgaXMgQVBJLkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fVxuICovXG5jb25zdCBoYXNTaW5nbGVOb2RlID0gKHsgY29uZmlnOiB7IEJpdEZpZWxkIH0sIGRhdGFtYXAsIG5vZGVtYXAgfSkgPT5cbiAgQml0RmllbGQucG9wY291bnQoZGF0YW1hcCkgPT09IDAgJiYgQml0RmllbGQucG9wY291bnQobm9kZW1hcCkgPT09IDFcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/path/InfiniteUint8Array.js":
/*!****************************************************************!*\
  !*** ./node_modules/@perma/map/src/path/InfiniteUint8Array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   hash64: () => (/* binding */ hash64),\n/* harmony export */   read: () => (/* binding */ read)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/path/api.js\");\n/* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Uint8Array.js */ \"(ssr)/./node_modules/@perma/map/src/path/Uint8Array.js\");\n/* harmony import */ var _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @multiformats/murmur3 */ \"(ssr)/./node_modules/@perma/map/node_modules/@multiformats/murmur3/src/index.js\");\n\n\n\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nconst hash64 = bytes =>\n  /** @type {Uint8Array} */ (_multiformats_murmur3__WEBPACK_IMPORTED_MODULE_2__.murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nconst configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nconst read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + (0,_Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__.toInt)(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvcGF0aC9JbmZpbml0ZVVpbnQ4QXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ1E7QUFDVTtBQUNqRDs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNPO0FBQ1AsYUFBYSxZQUFZLElBQUksNERBQVM7O0FBRXRDO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0MsYUFBYTtBQUNiO0FBQ08scUJBQXFCLDZCQUE2QjtBQUN6RDtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QztBQUNPLGdDQUFnQyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQUs7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvc3JjL3BhdGgvSW5maW5pdGVVaW50OEFycmF5LmpzPzJjNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL2FwaS5qc1wiXG5pbXBvcnQgeyB0b0ludCB9IGZyb20gXCIuL1VpbnQ4QXJyYXkuanNcIlxuaW1wb3J0IHsgbXVybXVyMzY0IH0gZnJvbSBcIkBtdWx0aWZvcm1hdHMvbXVybXVyM1wiXG5jb25zdCB1dGY4ID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNoNjQgPSBieXRlcyA9PlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIChtdXJtdXIzNjQuZW5jb2RlKGJ5dGVzKSlcblxuLyoqXG4gKiBAcGFyYW0ge1BhcnRpYWw8QVBJLk9wdGlvbnM8VWludDhBcnJheT4+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QVBJLlBhdGg8VWludDhBcnJheT59XG4gKi9cbmV4cG9ydCBjb25zdCBjb25maWd1cmUgPSAoeyBiaXRXaWR0aCA9IDgsIGhhc2ggPSBoYXNoNjQgfSkgPT4ge1xuICBjb25zdCBoYXNoU2l6ZSA9IGhhc2gobmV3IFVpbnQ4QXJyYXkoKSkuYnl0ZUxlbmd0aFxuICBjb25zdCBvcHRpb25zID0geyBiaXRXaWR0aCwgaGFzaCwgaGFzaFNpemUgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBhdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gICAqIEByZXR1cm5zIHtBUEkuVWludDMyfVxuICAgKi9cbiAgY29uc3QgYXQgPSAocGF0aCwgZGVwdGgpID0+IHJlYWQocGF0aCwgZGVwdGgsIG9wdGlvbnMpXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIGNvbnN0IGZyb20gPSBrZXkgPT4gdXRmOC5lbmNvZGUoa2V5KVxuXG4gIHJldHVybiB7IGF0LCBmcm9tLCBzaXplOiBJbmZpbml0eSB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5iaXRXaWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmhhc2hTaXplXG4gKiBAcGFyYW0geyhpbnB1dDpVaW50OEFycmF5KSA9PiBVaW50OEFycmF5fSBvcHRpb25zLmhhc2hcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWQgPSAoa2V5LCBkZXB0aCA9IDAsIHsgYml0V2lkdGggPSA4LCBoYXNoLCBoYXNoU2l6ZSB9KSA9PiB7XG4gIC8vIGtleSBkaWdlc3QgY29uc2lzdHMgb2YgaW5maW5pdGUgbnVtYmVyIG9mIGhhc2ggZnJhbWVzIHRoYXQgYXJlIGNvbXB1dGVkXG4gIC8vIGZyb20ga2V5ICsgZnJhbWUgbiB3aGljaCBsb29rcyBsaWtlXG4gIC8vIFtoYXNoKGtleSksIGhhc2goW2tleSwgMV0pLCBoYXNoKFtrZXksIG5dKV1cbiAgLy8gWW91IGNhbiB0aGluayBvZiB0aGUgaGFzaCBhcyBjb25jYXRpbmF0aW9uIG9mIGFsbCBmcmFtZXMuIEhlcmUgd2UgY2FsY3VsYXRlXG4gIC8vIGZyYW1lIGJpdCBzaXplIGZyb20gaGFzaCBzaXplIGFzIHdlIGdvaW5nIHRvIHVzZSB0aGF0IHNldmVyYWwgdGltZXMuXG4gIGNvbnN0IGZyYW1lQml0U2l6ZSA9IGhhc2hTaXplICogOFxuXG4gIC8vIFdlIHN0YXJ0IHdpdGggMCBkaWdlc3QgYW5kIHJlcXVpcmVkIGBiaXRDb3VudGAgY29ycmVzcG9uZGluZyB0byBgYml0V2l0aGAuXG4gIC8vIEluIHRoZSBsb29wIHdlJ2xsIGdvaW5nIHRvIGNvbnN1bWUgYGJpdENvdW50YCBoYXNoIGJpdHMuXG4gIGxldCBkaWdlc3QgPSAwXG4gIGxldCBiaXRDb3VudCA9IGJpdFdpZHRoXG4gIC8vIENhbGN1bGF0ZSBhYnNvbHV0ZSBiaXQgb2Zmc2V0IHdpdGhpbiB0aGUga2V5IGRpZ2VzdC5cbiAgbGV0IGJpdE9mZnNldCA9IGJpdFdpZHRoICogZGVwdGhcbiAgd2hpbGUgKGJpdENvdW50ID4gMCkge1xuICAgIC8vIFdlIGRlcml2ZSBmcmFtZSBudW1iZXIgYmFzZWQgb24gY3VycmVudCBiaXQgb2Zmc2V0LlxuICAgIGNvbnN0IGZyYW1lT2Zmc2V0ID0gKGJpdE9mZnNldCAvIGZyYW1lQml0U2l6ZSkgPj4gMFxuICAgIC8vIFRoZW4gd2UgY29tcHV0ZSB0aGF0IGhhc2ggZnJhbWVcbiAgICBjb25zdCBmcmFtZSA9XG4gICAgICBmcmFtZU9mZnNldCA9PT0gMCA/IGhhc2goa2V5KSA6IGhhc2goYXBwZW5kQnl0ZShrZXksIGZyYW1lT2Zmc2V0KSlcblxuICAgIC8vIGNvbXB1dGUgYml0IG9mZnNldCB3aXRoaW4gdGhlIGN1cnJlbnQgZnJhbWVcbiAgICBjb25zdCBvZmZzZXQgPVxuICAgICAgZnJhbWVCaXRTaXplIDw9IGJpdE9mZnNldCA/IGJpdE9mZnNldCAlIGZyYW1lQml0U2l6ZSA6IGJpdE9mZnNldFxuICAgIC8vIGNhbGN1bGF0ZSBudW1iZXIgb2YgYml0cyByZW1haW5pbmcgaW4gdGhpcyBmcmFtZVxuICAgIGNvbnN0IG1heEJpdHMgPSBmcmFtZUJpdFNpemUgLSBvZmZzZXRcbiAgICAvLyB3ZSB3aWxsIGNvbnN1bWUgYWxsIHJlcXVpcmVkIGJpdHMgZnJvbSBmcmFtZSBpZiBlbm91Z2ggYXJlIGF2YWlsYWJsZVxuICAgIC8vIG90aGVyd2lzZSB3ZSBjb25zdW1lIHdoYXRldmVyJ3MgYXZhaWxhYmxlIGFuZCBjb250aW51ZSByZXN0IGluIHRoZSBuZXh0XG4gICAgLy8gY3ljbGUocykuXG4gICAgY29uc3QgY291bnQgPSBtYXhCaXRzIDwgYml0Q291bnQgPyBtYXhCaXRzIDogYml0Q291bnRcbiAgICBkaWdlc3QgPSAoZGlnZXN0IDw8IGNvdW50KSArIHRvSW50KGZyYW1lLCBvZmZzZXQsIGNvdW50KVxuICAgIGJpdENvdW50IC09IGNvdW50XG4gICAgYml0T2Zmc2V0ICs9IGNvdW50XG4gIH1cblxuICByZXR1cm4gZGlnZXN0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKi9cbmNvbnN0IGFwcGVuZEJ5dGUgPSAoc291cmNlLCBieXRlKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ5dGVMZW5ndGggKyAxKS5maWxsKFxuICAgIGJ5dGUsXG4gICAgc291cmNlLmJ5dGVMZW5ndGhcbiAgKVxuICBieXRlcy5zZXQoc291cmNlKVxuICByZXR1cm4gYnl0ZXNcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/path/InfiniteUint8Array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/path/Uint32.js":
/*!****************************************************!*\
  !*** ./node_modules/@perma/map/src/path/Uint32.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   hash32: () => (/* binding */ hash32)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/path/api.js\");\n/* harmony import */ var murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! murmurhash3js-revisited */ \"(ssr)/./node_modules/murmurhash3js-revisited/index.js\");\n\n// @ts-expect-error - has no types\n\n\nconst utf8 = new TextEncoder()\n\n/**\n * @typedef {(bytes:Uint8Array) => API.Uint32} Hasher\n * @type {Hasher}\n */\nconst hash32 = murmurhash3js_revisited__WEBPACK_IMPORTED_MODULE_1__.x64.hash126\n\n/**\n * @param {Partial<API.Options<API.Uint32>>} options\n * @returns {API.Path<API.Uint32>}\n */\n/* c8 ignore next 45 */\nconst configure = ({ bitWidth = 5, hash = hash32 }) => {\n  const hashSize = 4\n  if (bitWidth > hashSize * 8) {\n    throw new RangeError(\n      `Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`\n    )\n  }\n\n  if (hashSize * 8 > 32) {\n    throw new RangeError(\n      `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`\n    )\n  }\n\n  // Mask for reading `bitWidth` number of bits from the end.\n  const mask = 0xffffffff >>> (32 - bitWidth)\n\n  /**\n   * Determines bit position for the path entry at the given `depth`.\n   * ```js\n   * const key = hash(\"result\") // 0b00011010010110010101111100110010\n   * // Which is following path (in reverse as we read from the right)\n   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]\n   * at(key, 0) // 0b10010 -> 18\n   * at(key, 1) // 0b11001 -> 25\n   * at(key, 2) // 0b10111 -> 23\n   * at(key, 3) // 0b10010 -> 18\n   * at(key, 4) // 0b00101 -> 5\n   * at(key, 5) // 0b01101 -> 13\n   * at(key, 6) // 0b00000 -> 0\n   * ```\n   *\n   * @param {API.Uint32} path\n   * @param {number} depth\n   */\n  const at = (path, depth) => (path >>> (depth * bitWidth)) & mask\n\n  /**\n   * @param {string} key\n   * @returns {API.Uint32}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { at, from, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvcGF0aC9VaW50MzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUMvQjtBQUM0Qzs7QUFFNUM7O0FBRUE7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxVQUFVO0FBQ1Y7QUFDTyxlQUFlLHdEQUFVOztBQUVoQztBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ08scUJBQXFCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSw2QkFBNkIsU0FBUztBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBOztBQUVBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL29jcHItd2ViLy4vbm9kZV9tb2R1bGVzL0BwZXJtYS9tYXAvc3JjL3BhdGgvVWludDMyLmpzPzU0YWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL2FwaS5qc1wiXG4vLyBAdHMtZXhwZWN0LWVycm9yIC0gaGFzIG5vIHR5cGVzXG5pbXBvcnQgbXVybXVyIGZyb20gXCJtdXJtdXJoYXNoM2pzLXJldmlzaXRlZFwiXG5cbmNvbnN0IHV0ZjggPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEB0eXBlZGVmIHsoYnl0ZXM6VWludDhBcnJheSkgPT4gQVBJLlVpbnQzMn0gSGFzaGVyXG4gKiBAdHlwZSB7SGFzaGVyfVxuICovXG5leHBvcnQgY29uc3QgaGFzaDMyID0gbXVybXVyLng2NC5oYXNoMTI2XG5cbi8qKlxuICogQHBhcmFtIHtQYXJ0aWFsPEFQSS5PcHRpb25zPEFQSS5VaW50MzI+Pn0gb3B0aW9uc1xuICogQHJldHVybnMge0FQSS5QYXRoPEFQSS5VaW50MzI+fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCA0NSAqL1xuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZSA9ICh7IGJpdFdpZHRoID0gNSwgaGFzaCA9IGhhc2gzMiB9KSA9PiB7XG4gIGNvbnN0IGhhc2hTaXplID0gNFxuICBpZiAoYml0V2lkdGggPiBoYXNoU2l6ZSAqIDgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBDYW4gbm90IHVzZSBiaXRXaWR0aCAke2JpdFdpZHRofSB3aGljaCBleGNlZWRzIHRoZSBoYXNoU2l6ZSAke2hhc2hTaXplfWBcbiAgICApXG4gIH1cblxuICBpZiAoaGFzaFNpemUgKiA4ID4gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBDYW4gbm90IHVzZSBoYXNoU2l6ZSAke2hhc2hTaXplfSBhcyBpdCBjYW4gbm90IGJlIGVuY29kZWQgaW4gVWludDMyYFxuICAgIClcbiAgfVxuXG4gIC8vIE1hc2sgZm9yIHJlYWRpbmcgYGJpdFdpZHRoYCBudW1iZXIgb2YgYml0cyBmcm9tIHRoZSBlbmQuXG4gIGNvbnN0IG1hc2sgPSAweGZmZmZmZmZmID4+PiAoMzIgLSBiaXRXaWR0aClcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBiaXQgcG9zaXRpb24gZm9yIHRoZSBwYXRoIGVudHJ5IGF0IHRoZSBnaXZlbiBgZGVwdGhgLlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBrZXkgPSBoYXNoKFwicmVzdWx0XCIpIC8vIDBiMDAwMTEwMTAwMTAxMTAwMTAxMDExMTExMDAxMTAwMTBcbiAgICogLy8gV2hpY2ggaXMgZm9sbG93aW5nIHBhdGggKGluIHJldmVyc2UgYXMgd2UgcmVhZCBmcm9tIHRoZSByaWdodClcbiAgICogLy8gMTAwMTAvMTEwMDEvMTAxMTEvMTAwMTAvMDAxMDEvMDExMDEvMDAwMDAgLT4gWyAxOCwgMjUsIDIzLCAxOCwgNSwgMTMsIDAgXVxuICAgKiBhdChrZXksIDApIC8vIDBiMTAwMTAgLT4gMThcbiAgICogYXQoa2V5LCAxKSAvLyAwYjExMDAxIC0+IDI1XG4gICAqIGF0KGtleSwgMikgLy8gMGIxMDExMSAtPiAyM1xuICAgKiBhdChrZXksIDMpIC8vIDBiMTAwMTAgLT4gMThcbiAgICogYXQoa2V5LCA0KSAvLyAwYjAwMTAxIC0+IDVcbiAgICogYXQoa2V5LCA1KSAvLyAwYjAxMTAxIC0+IDEzXG4gICAqIGF0KGtleSwgNikgLy8gMGIwMDAwMCAtPiAwXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0FQSS5VaW50MzJ9IHBhdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gICAqL1xuICBjb25zdCBhdCA9IChwYXRoLCBkZXB0aCkgPT4gKHBhdGggPj4+IChkZXB0aCAqIGJpdFdpZHRoKSkgJiBtYXNrXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybnMge0FQSS5VaW50MzJ9XG4gICAqL1xuICBjb25zdCBmcm9tID0ga2V5ID0+IGhhc2godXRmOC5lbmNvZGUoa2V5KSlcblxuICByZXR1cm4geyBhdCwgZnJvbSwgc2l6ZTogTWF0aC5jZWlsKChoYXNoU2l6ZSAqIDgpIC8gYml0V2lkdGgpIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/path/Uint32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/path/Uint8Array.js":
/*!********************************************************!*\
  !*** ./node_modules/@perma/map/src/path/Uint8Array.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   hash64: () => (/* binding */ hash64),\n/* harmony export */   toInt: () => (/* binding */ toInt)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/path/api.js\");\n/* harmony import */ var _multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/murmur3 */ \"(ssr)/./node_modules/@perma/map/node_modules/@multiformats/murmur3/src/index.js\");\n\nconst utf8 = new TextEncoder()\n;\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nconst hash64 = bytes =>\n  /** @type {Uint8Array} */ (_multiformats_murmur3__WEBPACK_IMPORTED_MODULE_1__.murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nconst configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nconst toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvcGF0aC9VaW50OEFycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCO0FBQy9CO0FBQ0EsQ0FBaUQ7O0FBRWpEO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQLGFBQWEsWUFBWSxJQUFJLDREQUFTOztBQUV0QztBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ08scUJBQXFCLDhCQUE4QixJQUFJO0FBQzlEOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vY3ByLXdlYi8uL25vZGVfbW9kdWxlcy9AcGVybWEvbWFwL3NyYy9wYXRoL1VpbnQ4QXJyYXkuanM/N2RjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBUEkgZnJvbSBcIi4vYXBpLmpzXCJcbmNvbnN0IHV0ZjggPSBuZXcgVGV4dEVuY29kZXIoKVxuaW1wb3J0IHsgbXVybXVyMzY0IH0gZnJvbSBcIkBtdWx0aWZvcm1hdHMvbXVybXVyM1wiXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgaGFzaDY0ID0gYnl0ZXMgPT5cbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAobXVybXVyMzY0LmVuY29kZShieXRlcykpXG5cbi8qKlxuICogQHBhcmFtIHtQYXJ0aWFsPEFQSS5PcHRpb25zPFVpbnQ4QXJyYXk+Pn0gb3B0aW9uc1xuICogQHJldHVybnMge0FQSS5QYXRoPFVpbnQ4QXJyYXk+fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyNSAqL1xuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZSA9ICh7IGJpdFdpZHRoID0gOCwgaGFzaCA9IGhhc2g2NCB9ID0ge30pID0+IHtcbiAgY29uc3QgaGFzaFNpemUgPSBoYXNoKG5ldyBVaW50OEFycmF5KCkpLmJ5dGVMZW5ndGhcblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwYXRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICAgKiBAcmV0dXJucyB7QVBJLlVpbnQzMn1cbiAgICovXG4gIGNvbnN0IGF0ID0gKHBhdGgsIGRlcHRoKSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZGVwdGggKiBiaXRXaWR0aFxuICAgIGlmIChvZmZzZXQgPiBoYXNoU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE91dCBvZiBib3VuZHNgKVxuICAgIH1cblxuICAgIHJldHVybiB0b0ludChwYXRoLCBvZmZzZXQsIGJpdFdpZHRoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBjb25zdCBmcm9tID0ga2V5ID0+IGhhc2godXRmOC5lbmNvZGUoa2V5KSlcblxuICByZXR1cm4geyBmcm9tLCBhdCwgc2l6ZTogTWF0aC5jZWlsKChoYXNoU2l6ZSAqIDgpIC8gYml0V2lkdGgpIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gYml0IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGJpdHMgdG8gY29uc3VtZVxuICovXG5leHBvcnQgY29uc3QgdG9JbnQgPSAoYnl0ZXMsIG9mZnNldCwgY291bnQpID0+IHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSAob2Zmc2V0IC8gOCkgfCAwXG4gIGxldCBiaXRPZmZzZXQgPSBvZmZzZXQgJSA4XG4gIGxldCBkZXNpcmVkID0gY291bnRcbiAgbGV0IGJpdHMgPSAwXG4gIHdoaWxlIChkZXNpcmVkID4gMCAmJiBieXRlT2Zmc2V0IDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGUgPSBieXRlc1tieXRlT2Zmc2V0XVxuICAgIGNvbnN0IGF2YWlsYWJsZSA9IDggLSBiaXRPZmZzZXRcblxuICAgIGNvbnN0IHRha2luZyA9IGF2YWlsYWJsZSA8IGRlc2lyZWQgPyBhdmFpbGFibGUgOiBkZXNpcmVkXG4gICAgY29uc3QgYml0c0xlZnQgPSA4IC0gYml0T2Zmc2V0IC0gdGFraW5nXG4gICAgLy8gbWFzayB0byB0dXJuIG9mIGJpdHMgYmVmb3JlIGJpdE9mZnNldFxuICAgIGNvbnN0IG1hc2sgPSAweGZmID4+IGJpdE9mZnNldFxuICAgIC8vIHR1cm4gb2ZmIG9mZnNldCBiaXRzIGFuZCBzaGlmdCB0byBkcm9wIHJlbWFpbmluZyBiaXQgb24gdGhlIHJpZ2h0XG4gICAgY29uc3QgdmFsdWUgPSAobWFzayAmIGJ5dGUpID4+IGJpdHNMZWZ0XG4gICAgYml0cyA9IChiaXRzIDw8IHRha2luZykgKyB2YWx1ZVxuXG4gICAgZGVzaXJlZCAtPSB0YWtpbmdcbiAgICBieXRlT2Zmc2V0KytcbiAgICBiaXRPZmZzZXQgPSAwXG4gIH1cblxuICByZXR1cm4gYml0c1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/path/Uint8Array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/path/api.js":
/*!*************************************************!*\
  !*** ./node_modules/@perma/map/src/path/api.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvcGF0aC9hcGkuanMiLCJtYXBwaW5ncyI6IjtBQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvcGF0aC9hcGkuanM/YzcwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge31cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/path/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@perma/map/src/unixfs.js":
/*!***********************************************!*\
  !*** ./node_modules/@perma/map/src/unixfs.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Path: () => (/* reexport module object */ _path_InfiniteUint8Array_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   bitField: () => (/* binding */ bitField),\n/* harmony export */   bitWidth: () => (/* binding */ bitWidth),\n/* harmony export */   builder: () => (/* binding */ builder),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   iterate: () => (/* binding */ iterate),\n/* harmony export */   tableSize: () => (/* binding */ tableSize)\n/* harmony export */ });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ \"(ssr)/./node_modules/@perma/map/src/lib.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ \"(ssr)/./node_modules/@perma/map/src/node.js\");\n/* harmony import */ var _path_InfiniteUint8Array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path/InfiniteUint8Array.js */ \"(ssr)/./node_modules/@perma/map/src/path/InfiniteUint8Array.js\");\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api.js */ \"(ssr)/./node_modules/@perma/map/src/api.js\");\n\n\n\n\n\n\n\n\nconst bitWidth = 8\nconst config = {\n  bitWidth,\n  Path: _path_InfiniteUint8Array_js__WEBPACK_IMPORTED_MODULE_2__.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nconst tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nconst empty = (options = /** @type {C} */ (config)) =>\n  _lib_js__WEBPACK_IMPORTED_MODULE_0__.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nconst builder = (options = /** @type {C} */ (config)) =>\n  _lib_js__WEBPACK_IMPORTED_MODULE_0__.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nconst from = (entries, options = /** @type {C} */ (config)) =>\n  _lib_js__WEBPACK_IMPORTED_MODULE_0__.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nconst bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nconst iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = _node_js__WEBPACK_IMPORTED_MODULE_1__.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: _node_js__WEBPACK_IMPORTED_MODULE_1__.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          _node_js__WEBPACK_IMPORTED_MODULE_1__.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvdW5peGZzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDQztBQUNtQjs7QUFFNUI7O0FBRVQ7O0FBRVI7QUFDQTtBQUNQO0FBQ0EsUUFBUSxrRUFBYyxHQUFHLFVBQVU7QUFDbkM7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNPOztBQUVQO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTyxvQ0FBb0MsR0FBRztBQUM5QyxFQUFFLDBDQUFVOztBQUVaO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTyxzQ0FBc0MsR0FBRztBQUNoRCxFQUFFLDRDQUFZOztBQUVkO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsWUFBWTtBQUN2QjtBQUNPLDRDQUE0QyxHQUFHO0FBQ3RELEVBQUUseUNBQVM7O0FBRVg7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLFdBQVcseURBQXlEO0FBQ3BFO0FBQ08sb0JBQW9CLDRCQUE0QixZQUFZO0FBQ25FOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWEsa0JBQWtCLDBDQUEwQyxFQUFFLG9EQUFvRDtBQUMvSDtBQUNPO0FBQ1AsVUFBVSwyQkFBMkI7QUFDckMsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQVk7QUFDM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQ0FBaUM7QUFDMUQsVUFBVSxpREFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2Nwci13ZWIvLi9ub2RlX21vZHVsZXMvQHBlcm1hL21hcC9zcmMvdW5peGZzLmpzPzE0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSEFNVCBmcm9tIFwiLi9saWIuanNcIlxuaW1wb3J0ICogYXMgTm9kZSBmcm9tIFwiLi9ub2RlLmpzXCJcbmltcG9ydCAqIGFzIFBhdGggZnJvbSBcIi4vcGF0aC9JbmZpbml0ZVVpbnQ4QXJyYXkuanNcIlxuXG5leHBvcnQgKiBmcm9tIFwiLi9hcGkuanNcIlxuXG5leHBvcnQgeyBQYXRoIH1cblxuZXhwb3J0IGNvbnN0IGJpdFdpZHRoID0gOFxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgYml0V2lkdGgsXG4gIFBhdGg6IFBhdGguY29uZmlndXJlKHsgYml0V2lkdGggfSksXG59XG5cbi8qKlxuICogQHBhcmFtIHtIQU1ULlBlcnNpc3RlbnRIYXNoTWFwfSBoYW10XG4gKi9cbmV4cG9ydCBjb25zdCB0YWJsZVNpemUgPSBoYW10ID0+IE1hdGgucG93KDIsIGhhbXQuY29uZmlnLmJpdFdpZHRoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBbVD11bmtub3duXVxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFtLPXN0cmluZ11cbiAqIEB0ZW1wbGF0ZSB7SEFNVC5Db25maWd9IFtDPUhBTVQuQ29uZmlnPFVpbnQ4QXJyYXk+XVxuICogQHBhcmFtIHtQYXJ0aWFsPEM+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7SEFNVC5QZXJzaXN0ZW50SGFzaE1hcDxULCBLLCBDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVtcHR5ID0gKG9wdGlvbnMgPSAvKiogQHR5cGUge0N9ICovIChjb25maWcpKSA9PlxuICBIQU1ULmVtcHR5KG9wdGlvbnMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPXVua25vd25dXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gW0s9c3RyaW5nXVxuICogQHRlbXBsYXRlIHtIQU1ULkNvbmZpZ30gW0M9SEFNVC5Db25maWc8VWludDhBcnJheT5dXG4gKiBAcGFyYW0ge1BhcnRpYWw8Qz59IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtIQU1ULkhhc2hNYXBCdWlsZGVyPFQsIEssIEM+fVxuICovXG5leHBvcnQgY29uc3QgYnVpbGRlciA9IChvcHRpb25zID0gLyoqIEB0eXBlIHtDfSAqLyAoY29uZmlnKSkgPT5cbiAgSEFNVC5idWlsZGVyKG9wdGlvbnMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFtWPXVua25vd25dXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gW0s9c3RyaW5nXVxuICogQHRlbXBsYXRlIHtIQU1ULkNvbmZpZ30gW0M9SEFNVC5Db25maWc8VWludDhBcnJheT5dXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFtLLCBWXT59IGVudHJpZXNcbiAqIEBwYXJhbSB7UGFydGlhbDxDPn0gb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgZnJvbSA9IChlbnRyaWVzLCBvcHRpb25zID0gLyoqIEB0eXBlIHtDfSAqLyAoY29uZmlnKSkgPT5cbiAgSEFNVC5mcm9tKGVudHJpZXMsIG9wdGlvbnMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBLXG4gKiBAdGVtcGxhdGUgQml0cywgQml0bWFwXG4gKiBAcGFyYW0ge0hBTVQuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgSEFNVC5Db25maWc8Qml0cywgQml0bWFwPj59IGhhbXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdEZpZWxkID0gKHsgZGF0YW1hcCwgbm9kZW1hcCwgY29uZmlnOiB7IEJpdEZpZWxkIH0gfSkgPT5cbiAgd2l0aG91dExlYWRpbmdaZXJvcyhCaXRGaWVsZC50b0J5dGVzKEJpdEZpZWxkLm9yKGRhdGFtYXAsIG5vZGVtYXApKSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmNvbnN0IHdpdGhvdXRMZWFkaW5nWmVyb3MgPSBieXRlcyA9PiB7XG4gIGxldCBvZmZzZXQgPSAwXG4gIHdoaWxlIChvZmZzZXQgPCBieXRlcy5ieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW29mZnNldF0gIT09IDApIHtcbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShvZmZzZXQpXG4gICAgfVxuICAgIG9mZnNldCArPSAxXG4gIH1cbiAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KG9mZnNldClcbn1cblxuLyoqXG4gKiBNYXBzIEhBTVQgbm9kZSBpbnRvIElQRlMgVW5peEZTIGNvbXBhdGlibGUgZm9ybWF0LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gS1xuICogQHRlbXBsYXRlIHtIQU1ULkNvbmZpZ30gQ1xuICogQHBhcmFtIHtIQU1ULkJpdG1hcEluZGV4ZWROb2RlPFQsIEssIEM+fSByb290XG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjx7cHJlZml4OnN0cmluZywga2V5OkssIHZhbHVlOlQsIG5vZGU/OnZvaWR9fHtwcmVmaXg6c3RyaW5nLCBub2RlOkhBTVQuQml0bWFwSW5kZXhlZE5vZGU8VCwgSywgQz59Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSBmdW5jdGlvbiogKHJvb3QpIHtcbiAgY29uc3QgeyBjb25maWcsIGRhdGFtYXAsIG5vZGVtYXAgfSA9IHJvb3RcbiAgY29uc3QgeyBCaXRGaWVsZDogYml0ZmllbGQgfSA9IGNvbmZpZ1xuICBjb25zdCBzaXplID0gYml0ZmllbGQuc2l6ZShkYXRhbWFwKVxuICBsZXQgYml0T2Zmc2V0ID0gMFxuICBsZXQgZGF0YUNvdW50ID0gMFxuICB3aGlsZSAoYml0T2Zmc2V0IDwgc2l6ZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IGJpdE9mZnNldC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCBcIjBcIilcbiAgICBpZiAoYml0ZmllbGQuZ2V0KGRhdGFtYXAsIGJpdE9mZnNldCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IE5vZGUua2V5QXQocm9vdCwgZGF0YUNvdW50KVxuICAgICAgeWllbGQge1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU6IE5vZGUudmFsdWVBdChyb290LCBkYXRhQ291bnQpLFxuICAgICAgfVxuICAgICAgZGF0YUNvdW50KytcbiAgICB9IGVsc2UgaWYgKGJpdGZpZWxkLmdldChub2RlbWFwLCBiaXRPZmZzZXQpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgLy8gVW5peEZTIG5ldmVyIGNvbnRhaW5zIGhhc2ggY29sbGlzaW9uIG5vZGVzIGJlY2F1c2UgaXQgdXNlc1xuICAgICAgICAvLyBpbmlmaW5pdGUgaGFzaGVzXG4gICAgICAgIG5vZGU6IC8qKiBAdHlwZSB7SEFNVC5CaXRtYXBJbmRleGVkTm9kZTxULCBLLCBDPn0gKi8gKFxuICAgICAgICAgIE5vZGUucmVzb2x2ZU5vZGUocm9vdCwgYml0T2Zmc2V0KVxuICAgICAgICApLFxuICAgICAgfVxuICAgIH1cbiAgICBiaXRPZmZzZXQrK1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@perma/map/src/unixfs.js\n");

/***/ })

};
;